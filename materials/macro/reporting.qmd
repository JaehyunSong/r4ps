---
title: "第10回講義資料"
subtitle: "分析結果の報告"
toc: true
metadata-files: 
  - _material.yml
---

## スライド {.unlisted}

<a href="../../slides/macro/reporting.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../../slides/macro/reporting.html" width="100%" style="aspect-ratio: 16 / 9.2;"></iframe>
```

:::{.callout-important}
## 解説は作成中です。

授業日まで完成します...!!!!!
:::

```{r}
#| include: false
options(width = 100)
pacman::p_load(tidyverse, modelsummary, marginaleffects, gghighlight)

# df <- read_csv("slides/Macro/Data/M1.csv")
df <- read_csv("Data/M1.csv")

fit1 <- lm(Score_Mean ~ Order, data = df)
fit2 <- lm(Score_Mean ~ Order + First, data = df)
fit3 <- lm(Score_Mean ~ Order + First + Duration, data = df)
```

## 分析結果をどう示すか

　前回までは線形回帰分析の理論、推定、解釈方法を紹介したが、この分析結果をレポートや論文に提示する場合はどうすれば良いだろうか。分析手法ごとに報告方法は異なるが、本講義では**線形回帰分析**に焦点を当てる[^reporting]。

[^reporting]: ロジスティック回帰分析、交互作用付きの回帰分析については今後解説する。

　それでは本日の実習で使用するパッケージとデータを読み込んでおこう。馴染みの{tidyverse}と{modelsummary}に加え、今回は{marginaleffects}というパッケージも使用する。宋がこの授業のためにセットアップしたJDCat分析ツールであれば、既にインストールされているが、自前のPCにインストールしたR + RStudioを使用する場合、コンソール上で`install.packages("marginaleffects")`と入力し、インストールしてから読み込んでおこう。

　データは`M1.csv`であり、LMSから入手可能だ。`read_csv()`内のパスは適宜修正すること。読み込んだデータは`df`と名付け、作業環境上に格納する。

```{r}
#| eval: false
library(tidyverse)
library(modelsummary)
library(marginaleffects)

df <- read_csv("Data/M1.csv")
```

　このデータは[ある暇な研究者](https://www.jaysong.net)が集めたM-1グランプリのデータの**一部**だ。フルバージョンのデータは[ここ](https://github.com/JaehyunSong/M-1_Grand_Pix)から入手できる。データは60行8列であり、各変数の詳細は以下の通りだ。

|変数名|説明|備考|
|:---|:------|:------|
|`No`|第X回大会|第13回（2017年）から|
|`Year`|大会年度||
|`Name`|コンビ名||
|`Duration`|結成からの経過年数||
|`First`|初出場ダミー|1 = 初出場 / 0 = その他|
|`Final`|ファイナルステージへの進出有無||
|`Order`|出場順番|1から10|
|`Score_Mean`|平均得点|7人の審査委員からの評価の平均値|

　分析に入る前にデータの記述統計を計算する。{summarytools}パッケージの`descr()`を使用するが、1回使うためにわざわざ{summarytools}を読み込むのも面倒なので、`summarytools::descr()`で関数を呼び出そう[^not_loaded_package]。

[^not_loaded_package]: 読み込んでいないパッケージの関数は`パッケージ名::関数名()`で使用可能だ。今回の場合以外にも、読み込んだ複数のパッケージに同じ名前の関数がある場合、「どのパッケージの関数か」を指定する際にも使用する。

```{r}
df |> 
  summarytools::descr(stats = c("mean", "sd", "min", "max", "n.valid"),
                      transpose = TRUE, order = "p")
```

　本日の内容は分析結果をどう報告するかに関するものなので、予めいくつかの回帰モデルを推定しておこう。今回は平均得点（`Score_Mean`）を応答変数とした線形回帰モデルを推定する。説明変数は出場順番（`Order`）、初出場ダミー（`First`）、芸歴（`Duration`）の3つを用意する。出場順番（`Order`）のみ投入した単回帰モデルを`fit1`、初出場ダミー（`First`）を加えたものを`fit2`、全て投入したモデルを`fit3`と名付ける。

```{r}
fit1 <- lm(Score_Mean ~ Order, data = df)
fit2 <- lm(Score_Mean ~ Order + First, data = df)
fit3 <- lm(Score_Mean ~ Order + First + Duration, data = df)
```

## 回帰表

### 単一モデルの例

　回帰分析の推定結果（切片や傾きの点推定値、標準誤差、信頼区間、$p$値、決定係数など）は`summary()`関数で簡単に確認できる。

```{r}
summary(fit3)
```

　しかし、これは**分析する側**が結果を確認するために用意されたものであり、「他人に見せる」ために用意されたものではない。レポートや論文に推定結果を示す場合は表を使う場合が多いが、`summary()`関数から得られたものはあくまでの文字列のみだ。ここで便利なのが{modelsummary}パッケージである[^stargazer]。使い方は簡単で`modelsummary(回帰オブジェクト名)`のみで良い。

[^stargazer]: {modelsummary}以外のも回帰表作成に特化した様々なパッケージがあり、その中でも{[stargazer](https://cran.r-project.org/web/packages/stargazer/index.html)}という根強い人気を誇るパッケージもある。$\LaTeX$ユーザーなら{stargazer}の方がカスタマイズの幅が広く、使い勝手が良いかも知れない。

```{r}
modelsummary(fit1)
```

　一発でかなりきれいな表ができた。デフォルトでは切片と傾き係数の点推定値と標準誤差（カッコ内）が表示される。また、分析に使用されたサンプルサイズ（Num.Obs.）や適合度指標（決定係数（R2）、調整済み決定係数（R2 Adj.））なども表示される。これでも十分良いが、ここからはより自分好みの表にするためにいくつかカスタマイズしてみよう。

　その前に前提知識として`modelsummary()`では各変数に対応する統計量が2行構成になっていることを意識する必要がある。デフォルトだと1行目は点推定値、2行目はその標準誤差である。`modelsummary()`関数では`estimate`（1行目）と`statistic`（2行目）引数で出力される統計量を変更することができる。デフォルトだと`estimate`は点推定値（`"{estimate}"`）、`statistic`は標準誤差（`"{std.error}"`）になっている。つまり、`modelsummary(オブジェクト名)`は`modelsummary(オブジェクト名, estiamte = "{estimate}", statistic = "{std.error}")`と同じコードだ。このように`"{統計量}"`の形式で表示する統計量が選択できる。たとえば、$p$値は`"{p.value}"`、95%信頼区間の下限は`"{conf.low}"`、上限は`"{conf.high}"`だ[^stars]。もし、特定の行を消したい場合は`NULL`を割り当てる。

[^stars]: 他にも`"{stars}"`というのもよく使われるが、これは邪悪なものなので間違ってでも調べないようにしよう。

　それではいくつかの例を確認してみよう。まずは標準誤差の代わりに$p$値を表示する例からだ。

```{r}
modelsummary(fit1, statistic = "({p.value})", note = "注：カッコ内はp値")
```

　切片（(Intercept)）の$p$値が`<0.001`と表示されているが、これは$p$値が0.001より小さい、つまり非常に小さいことを意味する。これなら$\alpha = 0.001$で検定を行っても統計的に有意であると判定できる水準である。また、`note`引数で表の下に注も付けることができる。2行目の統計量が何の統計量か分からない人もいるかも知れないので、このように付けておくことをおすすめする。

　次の例は、点推定値と標準誤差を一行にまとめる例だ。たとえば「点推定値 (標準誤差)」のようにまとめるとする。2行目（`statistics`）には`NULL`を割り当てて各変数の2行目を削除し、1行目（`estimate`）は`"{estimate} ({std.error})"`と指定すれば良い。

```{r}
modelsummary(fit1, 
             estimate  = "{estimate} ({std.error})",
             statistic = NULL,
             note      = "注：カッコ内は標準誤差")
```

　また、以下のように標準誤差を90%信頼区間に変えることもできる。デフォルトでは95%信頼区間が表示されるので、90%を使いたい場合は`conf_level`を0.9に変える必要がある。

```{r}
modelsummary(fit1, 
             conf_level = 0.9,
             estimate   = "{estimate}",
             statistic  = "[{conf.low}, {conf.high}]",
             note       = "注：カッコ内は90%信頼区間")
```

　モデルの当てはまりの良さ、評価指標として本講義では決定係数（$R^2$）と調整済み決定係数（Adjusted $R^2$）を紹介した。これらの統計量は適合度指標（goodness of fit; gof）と呼ばれるが、分析手法によって使用可能な適合度指標が異なる。{modelsummary}の`get_gof()`関数を使えば、使用可能な適合度指標が出力される。以下は`fit3`の適合度指標を出力するコードだ。

```{r}
get_gof(fit3)
```

　基本的には上記のすべての適合度指標が`modelsummary()`で出力されるが、`gof_map`引数で一部だけ出力させることもできる。今回のような線形回帰分析ならサンプルサイズ（`"nobs"`）、決定係数（`r.squared`）、調整済み決定係数（`"adj.r.squared"`）程度で十分だろう。それではこの3つの指標のみ出してみよう。3つの指標となるので`c()`でcharacter型ベクトルを割り当てれば良い。

```{r}
fit3 |> # パイプ演算子も使用可
  modelsummary(
    estimate  = "{estimate} ({p.value})",
    statistic = NULL,
    gof_map   = c("nobs", "r.squared", "adj.r.squared"),
    note      = "注：カッコ内はp値"
  )
```

### 複数モデルの例

　一つの表に複数の推定結果を並べることもでいる。方法は回帰オブジェクトを`list()`でまとめるだけだ。

```{r}
modelsummary(list(fit1, fit2, fit3),
             gof_map = c("nobs", "r.squared", "adj.r.squared"))
```

　自動的に（1）、（2）、...のようにモデル名が付くが`"モデル名" = オブジェクト名`のように書くと任意のモデル名も指定できる。

```{r}
modelsummary(list("Model 1" = fit1, "Model 2" = fit2, "Model 3" = fit3),
             gof_map = c("nobs", "r.squared", "adj.r.squared"))
```

　やや話がずれるが、表示される変数名を変えることもできる。変数名のままになると読者は「この変数って何？」と思うかも知れない。いきなり表を見せつけられても解釈ができる表が良い表なので、なるべく元の変数名ではなく、ちゃんと言葉で書いておこう。変数名の修正は`coef_rename`引数で調整でき、書き方は`"元の変数名" = "新しい変数名"`である。複数の変数名を変更する場合、`c()`でまとめる。

```{r}
modelsummary(list(fit1, fit2, fit3),
             coef_rename = c("(Intercept)" = "切片",
                             "Order"       = "出場順番",
                             "First"       = "初出場ダミー",
                             "Duration"    = "結成からの経過年数"),
             gof_map     = c("nobs", "r.squared", "adj.r.squared"))
```

### 回帰表の可視化

　余談だが、回帰表も図にすることができる。最近の政治学では回帰表を使う人も多いが、図で回帰表を示す人も急増している。ここでは{modelsummary}の`modelplot()`関数を紹介しよう。使い方は`modelsummary()`と非常に似ており、まず`modelplot()`内に回帰オブジェクト名を入れておけばそれっぽい図が生成される。

```{r}
#| fig-width: 4
#| fig-height: 3
modelplot(list("Model 1" = fit1, "Model 2" = fit2, "Model 3" = fit3),
          coef_omit = "(Intercept)", # <1>
          coef_map  = c("Duration", "First", "Order")) + # <2>
  geom_vline(xintercept = 0, linetype = 2) # <3>
```

1. 切片を表示しない
2. 表示順番を「下」からDuraion、First、Orderの順に
3. x = 0に破線を引く

　`modelplot()`から作成された図は{ggplot2}ベースなので`+`でレイヤーの追加および調整できる。本講義の履修者は{ggplot2}なしでは生きていけない人のはずなので非常に嬉しい知らせだろう。`modelplot()`の詳細はコンソール上で`?modelplot`を入力してヘルプを見るか[公式ページ](https://modelsummary.com/vignettes/modelplot.html)で確認してみよう。他にも{[coefplot](https://cran.r-project.org/web/packages/coefplot/index.html)}というパッケージも人気だ[^coefplotbl]。

[^coefplotbl]: 存在感のない{[coefplotbl](https://github.com/JaehyunSong/coefplotbl)}という謎のパッケージもある。興味のある方でも間違ってでも調べないこと。

## 予測値の可視化

　これまでは推定結果をどう示すかに焦点を当ててきた。回帰表のみを示し、言葉でその解釈をする程度で終わるレポート、論文も多いが、説明変数と応答変数間の関係をより直感的に示す方法もある。それは予測値を可視化することである。「出場順番が1番目は予測点数がXX点、2番目はYY点、....」というのを棒グラフや折れ線グラフなどで示すと、分析結果がより理解しやすくなるだろう。ここでは{marginaleffects}と{ggplot2}[^ggplot]パッケージを使用し、予測値を可視化方法を紹介する。具体的な手順は以下の通りだ。

[^ggplot]: {ggplot2}パッケージは{tidyverse}パッケージと一緒に読み込まれるので別途読み込む必要はない。

1. {marignaleffects}の`predictions()`関数で予測値[^logit]を計算し、オブジェクトとして格納する。ここから表形式オブジェクトが得られる。
2. 1から得られた表を加工する。`predictions()`から得られる表には規則があり、予測値は`estimate`列、信頼区間の下限と上限は`conf.low`と`conf.high`列という決まりがある。加工せず可視化に移るケースも多いが、必要があればラベル付けやfactor化などを施す。
3. {ggplot2}を用いて作図する。予測値と信頼区間（主に95%信頼区間を使用する）を示すのが一般的であり、横軸上の値が少ない場合、point-rangeプロット（`geom_pointrange()`）を、横軸上の値が多い場合、折れ線グラフ（`geom_line()`）とリボン（`geom_ribbon()`）を組み合わせて紹介する。

[^logit]: 今後紹介するロジスティック回帰分析の場合、`predictions()`関数を使うと予測「確率」が表示される。また、交差項を含むモデルの場合は予測値・予測確率以外にも`slopes()`関数で限界効果を計算し、可視化する必要がある。いずれも今後の講義で紹介する。

### 予測値の計算

　まず、予測値の計算から始めよう。ここでは3つの説明変数をすべて投入した`fit3`を利用する。最初の例として初出場ダミー（`First`）の値が0の場合と1の場合の、`Score_Mean`の予測値（$\widehat{\mbox{Score\_Mean}}$）はを計算してみよう。`fit3`の推定結果、以下のような1次関数が得られた。

$$
\widehat{\mbox{Score\_Mean}} = 89.605 + 0.258 \cdot \mbox{Order} - 0.963 \cdot \mbox{First} + 0.076 \cdot \mbox{Duration}.
$$

　この数式の`First`の箇所に0を入れた場合と、1を入れた場合の$\widehat{\mbox{Score\_Mean}}$を計算すれば良いが、問題は`Order`と`Duration`である。何らかの数字を入れる必要はあるが、ここに0を入れるのは不自然なのでここでは`Order`と`Duration`はその平均値（それぞれ5.5、10.6）を入れ、`First`だけ0と1を入れる。

:::{.callout-note}
## 平均値を代入する = 固定する

　「`Order`と`Duration`はその平均値（それぞれ5.5、10.6）を入れ、`First`だけ0と1を入れる」という言葉は、論文では「`Order`と`Duration`はその平均値に**固定**し、`First`のみを動かす」とよく表現される。今回の例だと「`First`以外の共変量はすべて平均値に固定する」とも言えよう。
:::

　まず、初出場（`First = 1`）の場合の平均得点の予測値を計算してみよう。

```{r}
89.605 + 0.256 * 5.5 - 0.963 * 1 + 0.076 * 10.6
```

　続いて、初出場ではない（`First = 0`）場合も計算してみよう。

```{r}
89.605 + 0.256 * 5.5 - 0.963 * 0 + 0.076 * 10.6
```

　他の条件が平均である場合、初出場コンビの予測平均得点は`r 89.605 + 0.256 * 5.5 - 0.963 * 1 + 0.076 * 10.6`点、2回以上出場したコンビの予測平均得点は`r 89.605 + 0.256 * 5.5 - 0.963 * 0 + 0.076 * 10.6`点である。

　今回は`First`の値が2種類（0と1）しかなかったため、これだけでも良いかも知れないが、`Order`や`Duration`は10以上の値で構成されているため、このような作業は非常に面倒だ。ここで、{marginaleffects}の`predictions()`関数を使えば簡単に計算ができるようになる。使い方は以下の通りだ。

```{r}
#| eval: false
新しいオブジェクト名 <- predictions(回帰オブジェクト名,
                                 newdata = datagrid(変数 = 値))
```

　全く同じ計算を`predictions()`関数で行い、結果を`fit3_pred1`という名の新しいオブジェクトを作業環境内に格納する。

```{r}
fit3_pred1 <- predictions(fit3,
                          newdata = datagrid(First = c(0, 1)))

fit3_pred1
```

　この結果に無駄な情報はないが、とりあえず注目するのは`First`の値、予測値、予測値の不確実性指標（主に信頼区間）である。ここでは`Estimate`列が予測値、`2.5%`と`97.5%`列が95%信頼区間の下限と上限だ。また、`Order`と`Duration`列を見るとそれぞれ5.5と10.6で固定されていることが分かる。

　むろん、`First`以外の変数を平均値以外に固定することもできる。何より、「出場順番が5.5」というのはあり得ないし、芸歴10.6年というのも分かりにくい。以下では先ほどと同じ計算をするが、出場順番を5番目、芸歴を5年に固定してみよう。これは`datagrid()`内で指定できる。

```{r}
fit3_pred2 <- predictions(fit3,
                          newdata = datagrid(First    = c(0, 1),
                                             Order    = 5,
                                             Duration = 5))

fit3_pred2
```

### 作図

作図の際の注意事項

* `fit3_pred2`で表示される列名は「本当の」列名ではない!!
   * ユーザーが読みやすいように列名が変更されてから出力される。
   * たとえば、予測値の本当の列名は`estimate`だが、表示名は`Estimate`になっている。
* 「本当の」列名が見たい場合は`print(オブジェクト名, style = "data.frame")`

```{r}
print(fit3_pred2, style = "data.frame")
```

* 作図によく使うのは予測値（`estimate`）、信頼区間の下限（`conf.low`）と上限（`conf.high`）、動かしている変数名（ここでは`First`）

作図の例

Pointrangeプロットを使用する。

`geom_pointrange()`レイヤー

* `x`：説明変数
* `y`：予測値
* `ymin`：信頼区間の下限
* `ymax`：信頼区間の上限
   
```{r}
fit3_pred2_plot1 <- fit3_pred2 |> 
  ggplot() +
  geom_pointrange(aes(x = First, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "初出場ダミー", 
       y = "予測点数と95%信頼区間") +
  theme_bw(base_size = 12)

fit3_pred2_plot1
```

無駄の目盛りの削除

* 横軸（X軸）の無駄な目盛りを削除し、0と1のみ残す。

`scale_x_continuous()`で目盛り調整

* `breaks`：目盛りの位置
* `labels`：目盛りのラベル
   
```{r}
fit3_pred2_plot1 +
  scale_x_continuous(breaks = c(0, 1),
                     labels = c("0", "1"))
```

出場順番と平均得点間の関係（計算）

```{r}
fit3_pred3 <- predictions(fit3, newdata = datagrid(Order = 1:10))
fit3_pred3
```

出場順番と平均得点間の関係（可視化）

```{r}
#| fig-width: 7
#| fig-height: 3.5
#| dpi: 175
fit3_pred3 |> 
  ggplot() +
  geom_pointrange(aes(x = Order, y = estimate, ymin = conf.low, ymax = conf.high)) +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  labs(x = "出場順番", y = "平均得点の予測値と95%信頼区間") +
  theme_bw(base_size = 12)
```

芸歴と平均得点間の関係（計算）

```{r}
fit3_pred4 <- predictions(fit3, newdata = datagrid(Duration = 2:16))
fit3_pred4
```

芸歴と平均得点間の関係（可視化）

```{r}
#| fig-width: 7
#| fig-height: 3.5
#| dpi: 175
fit3_pred4 |> 
  ggplot() +
  geom_pointrange(aes(x = Duration, y = estimate, ymin = conf.low, ymax = conf.high)) +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  labs(x = "コンビ結成からの経過年数", y = "平均得点の予測値と95%信頼区間") +
  theme_bw(base_size = 12)
```

折れ線グラフとリボン（`geom_ribbon()`）の組み合わせ

* 横軸が細かいほどpoint-rangeプロットは気持ち悪くなる（ムカデのような見た目になる）。
* `geom_ribbon()`は`x`、`ymin`、`ymax`にマッピング
   * `geom_pointrange()`と使い方は同じだが、予測値の情報を持たないため、`y`は不要

```{r}
#| fig-width: 8
#| fig-height: 3
#| dpi: 150
fit3_pred4 |> 
  ggplot() +
  geom_ribbon(aes(x = Duration, ymin = conf.low, ymax = conf.high)) +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  labs(x = "コンビ結成からの経過年数", y = "平均得点の予測値と95%信頼区間") +
  theme_bw(base_size = 12)
```

折れ線グラフ + リボン

```{r}
#| fig-width: 8
#| fig-height: 4
#| dpi: 150
fit3_pred4 |> 
  ggplot(aes(x = Duration)) + # <1>
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "gray70") + # <2>
  geom_line(aes(y = estimate), linewidth = 1) + # <3>
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  labs(x = "コンビ結成からの経過年数", y = "平均得点の予測値と95%信頼区間") +
  theme_bw(base_size = 12)
```

1. `geom_ribbon()`と`geom_line()`は同じ横軸を共有するため、ここでマッピングした方が効率的
2. デフォルトのリボンは暗い色なので、明るめの色に変える。
3. `linewidth`で折れ線グラフの太さを調整（1だとデフォルトよりやや太め）

## 信頼区間の話

出場順番と平均得点間の関係

今回得られた回帰直線

```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 4
#| dpi: 150
tibble(case = c("Real", "Case 1", "Case 2", "Case 3"),
       start = c(90.16668, 90, 89.1, 91.2),
       end   = c(92.49046, 93, 93.6, 91.2)) |> 
  mutate(case = fct_relevel(case, "Real")) |> 
  filter(case == "Real") |> 
  ggplot() +
  geom_segment(aes(x = 1, xend = 10, y = start, yend = end),
               linewidth = 1.5) +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  labs(x = "出場順番", y = "平均得点の予測値") +
  coord_cartesian(ylim = c(85, 95), xlim = c(1, 10.5)) +
  theme_bw(base_size = 12)
```

もう一度、過去に戻ってM-1をやったら...

こんな回帰直線が得られたとしてもおかしくはない（多分）

```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 4
#| dpi: 150
tibble(case = rep(c("今回のデータ", "ケース1", "ケース2", "ケース3"), each = 2),
       x    = rep(c(1, 10), 4),
       y    = c(90.16668, 92.49046,
                  90, 93,
                  89.1, 93.6,
                  91.2, 92)) |> 
  mutate(case = fct_relevel(case, "今回のデータ")) |> 
  ggplot() +
  geom_line(aes(x = x, y = y, color = case),
               linewidth = 1.5) +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  gghighlight(!is.na(case), label_key = case,
              label_params = list(direction = "y", hjust = 0)) +
  labs(x = "出場順番", y = "平均得点の予測値") +
  coord_cartesian(ylim = c(85, 95), xlim = c(1, 10.5)) +
  theme_bw(base_size = 12)
```

こんな回帰直線が得られる可能性は非常に低い（多分）

```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 4
#| dpi: 150
tibble(case = rep(c("今回のデータ", "ケース4", "ケース5", "ケース6"), each = 2),
       x    = rep(c(1, 10), 4),
       y    = c(90.16668, 92.49046,
                90, 95,
                91, 90,
                92.5, 88)) |> 
  mutate(case = fct_relevel(case, "今回のデータ")) |> 
  ggplot() +
  geom_line(aes(x = x, y = y, color = case),
            linewidth = 1.5) +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  gghighlight(!is.na(case), label_key = case,
              label_params = list(direction = "y", hjust = 0)) +
  labs(x = "出場順番", y = "平均得点の予測値") +
  coord_cartesian(ylim = c(85, 95), xlim = c(1, 10.5)) +
  theme_bw(base_size = 12)
```

信頼区間の意味

この範囲（信頼区間）外の直線が得られる可能性は非常に低い！

```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 4
#| dpi: 150
tibble(case = rep(c("今回のデータ", "ケース1", "ケース2", "ケース3",
                    "ケース4", "ケース5", "ケース6"), each = 2),
       x    = rep(c(1, 10), 7),
       y    = c(90.16668, 92.49046,
                90, 93,
                89.1, 93.6,
                91.2, 92,
                90, 95,
                91, 90,
                92.5, 88)) |> 
  mutate(case = fct_relevel(case, "今回のデータ")) |> 
  ggplot() +
  geom_ribbon(data = fit3_pred3,
              aes(x = Order, ymin = conf.low, ymax = conf.high),
              fill = "gray80") +
  geom_line(aes(x = x, y = y, color = case),
            linewidth = 1.5) +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  gghighlight(case %in% c("今回のデータ", paste0("ケース", 4:6)), label_key = case,
              unhighlighted_params = list(color = "gray30"),
              label_params = list(direction = "y", hjust = 0)) +
  labs(x = "出場順番", y = "平均得点の予測値") +
  coord_cartesian(ylim = c(85, 95), xlim = c(1, 10.5)) +
  theme_bw(base_size = 12)
```

傾き係数が正（負）に統計的有意であれば、この区間内に引ける直線は必ず右上がり（右下がり）となる。

* $\alpha$ = 0.05で統計的有意だった`Order`（$p$ = 0.016）は、95%信頼区間内に右上がりの直線しか引けない。
* 右は統計的に有意でない`Duration`変数の例（$p$ = 0.381）
   * 水平線も、右上がり直線も、右下がり直線も引ける。
   * $\Rightarrow$ `Duration`と`Score_Mean`の関係は現段階では判断できない。
* $\alpha$ = 0.1を仮定するのであれば、90%（$= (1 - \alpha) \times 100$）信頼区間を使うこととなる。

```{r}
#| fig-width: 6
#| fig-height: 4
fit3_pred4 |> 
  ggplot(aes(x = Duration)) + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "gray70") +
  geom_segment(aes(x = 2, xend = 16, y = 91, yend = 91),
               linewidth = 1.5, color = "#00798C") +
  geom_segment(aes(x = 2, xend = 16, y = 90, yend = 92),
               linewidth = 1.5, color = "#D1495B") +
  geom_segment(aes(x = 2, xend = 16, y = 92, yend = 91),
               linewidth = 1.5, color = "#66A182") +
  geom_line(aes(y = estimate), linewidth = 1.5) +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  labs(x = "コンビ結成からの経過年数", y = "平均得点の予測値と95%信頼区間") +
  coord_cartesian(ylim = c(88, 93)) +
  theme_bw(base_size = 12)
```

有意水準と信頼区間

（ありえないが、）$\alpha$ = 0.6を採用する場合、40%信頼区間（$(1 - \alpha) \times 100$%信頼区間）を使うことになる。

* 以下は40%信頼区間を採用した例（`predictions()`内に`conf_level = 0.4`を追加する）
   * ただし、よく使うのは90%（$\alpha$ = 0.1）、95%（$\alpha$ = 0.05）、99%（$\alpha$ = 0.01）信頼区間

```{r}
#| fig-width: 6
#| fig-height: 4
predictions(fit3, newdata = datagrid(Duration = 2:16),
            conf_level = 0.4) |>
  ggplot(aes(x = Duration)) + 
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), fill = "gray70") +
  geom_segment(aes(x = 2, xend = 16, y = 91.09444, yend = 91.44930),
               linewidth = 1, color = "#00798C") +
  geom_segment(aes(x = 2, xend = 16, y = 90.26250, yend = 92.02425),
               linewidth = 1, color = "#D1495B") +
  geom_line(aes(y = estimate), linewidth = 1.5) +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  labs(x = "コンビ結成からの経過年数", y = "平均得点の予測値と95%信頼区間") +
  coord_cartesian(ylim = c(88, 93)) +
  theme_bw(base_size = 12)
```
