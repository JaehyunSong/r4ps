---
title: "第10回講義資料"
subtitle: "回帰分析の可視化"
toc: true
metadata-files: 
  - _material.yml
---

## スライド {.unlisted}

<a href="../../slides/macro/reporting.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../../slides/macro/reporting.html" width="100%" style="aspect-ratio: 16 / 9.2;"></iframe>
```

## セットアップ

```{r}
#| include: false
pacman::p_load(tidyverse, gt, summarytools, modelsummary,
               marginaleffects)

# df <- read_csv("materials/macro/Data/M1.csv")
df <- read_csv("Data/M1.csv")

fit_lm     <- lm(Score_Mean ~ Order + First + Duration, data = df)
fit_logit  <- glm(Final ~ Order + First + Duration, data = df, 
                  family = binomial("logit"))
fit_inter1 <- lm(Score_Mean ~ Order * First + Duration, data = df)
fit_inter2 <- lm(Score_Mean ~ Order * Duration + First, data = df)
```

　本日使用するパッケージとLMSからダウンロードして実習用データを読み込む。読み込むデータは`df`に格納し、中身を確認してみよう。

```{r}
#| filename: "Code 01"
library(tidyverse)
library(modelsummary)
library(summarytools)
library(marginaleffects)

df <- read_csv("Data/M1.csv")

df
```

　続いて、`df`の記述統計量を計算する。コンビー名（`Name`）列の記述統計は不要であるため、予め除外しておこう。

```{r}
#| filename: "Code 02"
df |>
  select(-Name) |>
  descr(stats = c("mean", "sd", "min", "max", "n.valid"),
        transpose = TRUE, order = "p")
```

　データの紹介は以下ととおりである。

|変数名|説明|備考|
|:---|:------|:------|
|`No`|第X回大会||
|`Year`|大会年度||
|`Name`|コンビ名||
|`Duration`|結成からの経過年数||
|`First`|初出場ダミー||
|`Final`|ファイナルステージへの進出有無||
|`Order`|出場順番|1から10|
|`Score_Mean`|平均得点|7人の審査委員からの評価の平均値|

　今回は`df`を使って、M-1グランプリにおける出場順番と得点の関係を調べるとする。応答変数は得点の合計を審査委員の数で割った値である平均得点（`Score_Mean`）とファイナルステージへの進出有無（`Final`）である。説明変数は出場順番（`Order`; 主な説明変数）、初出場ダミー（`First`）、コンビー結成からの経過年数（`Duration`）である。また、出場順番と初出場ダミー、または経過年数の交互作用も検討し、交互作用を仮定しない変数は統制変数として投入する。ここでは以下の4モデルを推定するとしよう。

* `fit_lm`: 線形回帰分析（応答変数: 平均得点）
* `fit_logit`: ロジスティック回帰分析（応答変数: ファイナルステージへの進出有無）
* `fit_inter1`: 線形回帰分析 + 交互作用（ダミー変数）
   * 調整変数は「初出場ダミー」
* `fit_inter2`: 線形回帰分析 + 交互作用（連続変数）
   * チョ制変数は「コンビー結成からの経過年数」

```{r}
#| filename: "Code 03"
fit_lm     <- lm(Score_Mean ~ Order + First + Duration, data = df)
fit_logit  <- glm(Final ~ Order + First + Duration, data = df, 
                  family = binomial("logit"))
fit_inter1 <- lm(Score_Mean ~ Order * First + Duration, data = df)
fit_inter2 <- lm(Score_Mean ~ Order * Duration + First, data = df)
```

　{modelsummary}の`modelsummary()`関数を使って、4つのモデルを概観してみよう。

```{r}
#| filename: "Code 04"
modelsummary(list("線形"           = fit_lm, 
                  "ロジスティック" = fit_logit, 
                  "交互作用（1）"  = fit_inter1, 
                  "交互作用（2）"  = fit_inter2),
             statistic = "({p.value})")
```

## 線形回帰分析

　線形回帰分析の場合、推定結果を表で示すだけでも良いが、予測値のグラフも示すと読者によってより理解しやすくなる。今回の例（`fit_lm`）の場合、出場順番（`Order`）と平均得点間の関係をグラフを示してみよう。出場順番は1番目から10番目まであるため、`Order`の値が1、2、3、...、10の場合に対し、予測値（平均得点の予測値）とその95%信頼区間を出してみよう。使用するのは{marginaleffects}の`predictions()`関数である。

　第1引数は回帰分析のオブジェクト名、第2引数は`newdata`に`datagrid()`関数を割り当てたものである。`datagrid()`の中には`説明変数名 = 値`を指定する。`1`のみなら`Order = 1`の場合の予測値が計算され、`c(1, 2, 3)`なら`Order`の値が1、2、3の場合の予測値が計算される。公差1の等差数列は`:`演算子で表現することもできるので、今回は`1:10`とする。計算結果は`lm_pred`に格納し、出力する。

```{r}
#| filename: "Code 05"
lm_pred <- predictions(fit_lm, newdata = datagrid(Order = 1:10))

lm_pred
```

　大量の列が出力されているが、作図のために必要な変数は`Order`（出場順番）、`estimate`（予測値）、`conf.low`（95%信頼区間の下限）、`conf.high`（95%信頼区間の上限）列のみだ。これらに`std.error`列を加え、`lm_pred`を上書きしよう。

```{r}
#| filename: "Code 06"
lm_pred <- lm_pred |>
  select(Order, estimate, std.error, conf.low, conf.high)

lm_pred
```

　だいぶ読みやすい表としてまとまった。あとは、この`lm_pred`オブジェクトを使って作図をするだけだ。点推定値と区間を同時に示すときにはpoint-rangeプロットが有効である（本資料の後半では線と面を組み合わせたグラフの作り方も紹介するが、その方法でも良い）。使用する幾何オブジェクトは`geom_pointrange()`であり、`aes()`内部でマッピングを行う。最低でも`x`、`y`、`ymin`、`ymax`のマッピングが必要であり、`x`と`y`はそれぞれ横軸と縦軸に対応する変数、`ymin`と`ymax`は区間の下限と上限に対応する変数を指定する。また、横軸の目盛りを1刻みにするため、`scale_x_continuous()`レイターを足す。`scale_x_continuous()`は`breaks`に目盛りの位置を、`labels`には各目盛りに付けるラベルのベクトルを割り当てる。`breaks`と`labels`は同じ長さのベクトルである必要がある。

```{r}
#| filename: "Code 07"
#| fig-width: 8
#| fig-height: 4
lm_pred |>
  ggplot() +
  geom_pointrange(aes(x = Order, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "出場順番", y = "平均得点（100点満点）") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14)
```

　各point-rangeを線で繋ぐためには`geom_line()`オブジェクトで折れ線グラフを追加する。

```{r}
#| filename: "Code 08"
#| fig-width: 8
#| fig-height: 4
lm_pred |>
  ggplot() +
  geom_pointrange(aes(x = Order, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  geom_line(aes(x = Order, y = estimate)) +
  labs(x = "出場順番", y = "平均得点（100点満点）") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14)
```

　この場合、`geom_pointrange()`と`geom_line()`は`x`と`y`に対して同じマッピングを共有するため、`ggplot()`内部でマッピングした方がより効率的な書き方だ。

```{r}
#| filename: "Code 09"
#| fig-width: 8
#| fig-height: 4
lm_pred |>
  ggplot(aes(x = Order, y = estimate)) +
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high)) +
  geom_line() +
  labs(x = "出場順番", y = "平均得点（100点満点）") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14)
```

　ここで予測値の図における95%信頼区間の意味について説明する。先程の図における右上がりの直線が実は「**回帰直線**（regression line）」であり、2つの変数の関係を1次関数で示したのもである。しかし、1次関数の係数（$\alpha$や$\beta_1$など）には不確実性が存在し、だからこそ統計的有意性検定を行うことである。これらの係数が1次関数の切片と傾きであるが、不確実性が存在する以上、回帰直線にも不確実性が存在すると考えた方が自然だろう。この95%信頼区間の内部には以下のように無数の直線が引ける。

```{r}
#| echo: false
#| fig-width: 8
#| fig-height: 5
lm_pred |>
  ggplot() +
  geom_ribbon(aes(x = Order, ymin = conf.low, ymax = conf.high),
              fill = "gray80") +
  geom_segment(aes(x = 1, xend = 10, y = 89.79568, yend = 92.59860),
               color = "blue", linewidth = 1) +
  geom_segment(aes(x = 1, xend = 10, y = 88.58862, yend = 93.80567),
               color = "darkgreen", linewidth = 1) +
  geom_segment(aes(x = 1, xend = 10, y = 91.00274, yend = 91.39154),
               color = "orange", linewidth = 1) +
  geom_segment(aes(x = 1, xend = 10, y = 90, yend = 91.5),
               color = "red", linewidth = 1) +
  geom_segment(aes(x = 1, xend = 10, y = 90.5, yend = 93.1),
               color = "red", linewidth = 1) +
  labs(x = "出場順番", y = "平均得点（100点満点）") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14)
```

　青色の直線が推定結果から得られた回帰直線であるが、青以外の直線も95%信頼区間内部に存在する。これらの直線は今回の推定結果から得られた直線ではないが、**あり得る**回帰直線である。つまり、もう一度、2013年から同じやり方でM-1グランプリを実施し、同じやり方でデータ収集&分析をすれば、緑やオレンジ色のような回帰直線が得られたとしてもそこまで不思議ではないことを意味する。ちなみにここで最も説明変数の影響力が小さいのはオレンジ色の直線である。一つ言えるのは、説明変数の傾き係数が統計的有意であれば、いくら効果量が小さい直線であっても、右上がり関係を示すことである（つまり、右下がりにはならない）。一方、統計的に有意でない場合は、区間内に右上がりと右下がりの直線が共存することになる。

## ロジスティック回帰分析

　ロジスティック回帰分析は線形回帰分析とは区別される手法であるが、説明変数の値ごとの予測値を可視化する方法は同じだ。つまり、`predictions()`で予測値を計算し、その計算結果が格納された表形式データ（data.frame、またはtibbleと呼ばれる）と{ggplot2}を用いた作図をするだけだ。まずは`Order`の値が1、2、...、10の場合のファイナルステージへの進出確率の予測値を計算し、`logit_pred`に格納する。この`logit_pred`を使ってそのまま作図へ移行しても良いが、自分で具体的な数値を確認したい場合は、必要な列だけ抽出しておくと良い。

```{r}
#| filename: "Code 10"
logit_pred <- predictions(fit_logit, newdata = datagrid(Order = 1:10))

logit_pred <- logit_pred |>
  select(Order, estimate, conf.low, conf.high)

logit_pred
```

　続いて、{ggplot2}を用いて作図をする。基本的に線形回帰分析と同じコードであるが、今回の縦軸は「平均得点」の予測値でなく、「ファイナルステージへの進出確率」の予測値であるため、軸ラベルを修正する。

```{r}
#| filename: "Code 10"
#| fig-width: 8
#| fig-height: 4
logit_pred |>
  ggplot() +
  geom_pointrange(aes(x = Order, y = estimate, ymin = conf.low, ymax = conf.high)) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14)
```

## 交互作用

### 予測値（調整変数がダミー変数）

　交差項を含むモデル（線形回帰・ロジスティック回帰両方）の場合でも基本的な手順はこれまでと同じである。しかし、主な説明変数（ここでは`Order`）が応答変数に与える影響は調整変数（ここでは`First`、または`Duration`）によって異なる。したがって、調整変数の値ごとに別々の回帰直線を計算する必要がある。そのためには`predictions()`の`newdata = datagrid()`内に主な説明変数だけでなく、調整変数の値も指定する必要がある。たとえば、調整変数がダミー変数（ここでは`First`）の場合、`First`の値が0と1の場合に分けて、`Order`の値が1、2、3、...、10の場合の予測値を計算する必要がある。

```{r}
#| filename: "Code 11"
inter1_pred <- predictions(fit_inter1, newdata = datagrid(Order = 1:10,
                                                          First = 0:1))

inter1_pred
```

　作図に必要な列（+標準誤差である`std.error`列）のみを抽出する。今回の例は`Order`以外にも`First`の値も2パターン（0と1）あるため、`First`列も抽出する。

```{r}
#| filename: "Code 12"
inter1_pred <- inter1_pred |>
  select(Order, First, estimate, std.error, conf.low, conf.high)

inter1_pred
```

　続いて、`First`列をリコーディングする。分析する側は`First`の値が1だと「初出場」、0だと「出場経験あり」とうことが分かるが、一般読者は分からないだろう。ここでは`First`をfactor化し、0と1にそれぞれ「出場経験あり」、「初出場」とラベルを付けておこう。

```{r}
#| filename: "Code 13"
inter1_pred <- inter1_pred |>
  mutate(First = factor(First, levels = c(0, 1), labels = c("出場経験あり", "初出場")))

inter1_pred
```

　それでは作図をしてみよう。作図のコードもこれまでと大きく変わらない。しかし、今回は「初出場」か「出場経験あり」かで別のpoint-rangeが出力される。この2種類のpoint-rangeを今回は**色分け**してみよう。特定の変数の値に応じて色分けをする場合は`aes()`の内部で`color`変数にその変数を指定する。ここだと、`color = First`となる。

```{r}
#| filename: "Code 14"
#| fig-width: 8
#| fig-height: 4
inter1_pred |>
  ggplot() +
  geom_pointrange(aes(x = Order, y = estimate, 
                      ymin = conf.low, ymax = conf.high,
                      color = First)) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", color = "") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14) +
  theme(legend.position = "bottom")
```

　これだと予測値（点）と信頼区間（線）が重なって読みにくい。このように予測値/限界効果を2つ以上のグループに分けて可視化する場合は、線（line）と面（ribbon）を組み合わせた方が良い。まずは、折れ線グラフを追加してみよう。折れ線グラフの幾何オブジェクトは`geom_line()`だ。折れ線グラフは基本的に`x`と`y`のみマッピングで良いが、ここでは`First`の値ごとに線の色分けがしたいので`color`にもマッピングする。

```{r}
#| filename: "Code 15"
#| fig-width: 8
#| fig-height: 4
inter1_pred |>
  ggplot() +
  geom_line(aes(x = Order, y = estimate, color = First)) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", color = "") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14) +
  theme(legend.position = "bottom")
```

　つづいて、信頼区間だ。信頼区間を面で示す場合は`geom_ribbon()`幾何オブジェクトを使用する。マッピングは`geom_pointrange()`と似ているが、`y`のマッピングは不要である。また、線の色は`color`にマッピングをしたが、面の色は`fill`である。

```{r}
#| filename: "Code 16"
#| fig-width: 8
#| fig-height: 4
inter1_pred |>
  ggplot() +
  geom_line(aes(x = Order, y = estimate, color = First)) +
  geom_ribbon(aes(x = Order, ymin = conf.low, ymax = conf.high,
                  fill = First)) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", 
       color = "", fill = "") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14) +
  theme(legend.position = "bottom")
```

　今回は面が重なってしまう。しかも線と面が同じいろなので、線が見えなくなってしまった。この場合は面を半透明にすれば良い。すべての面に適用するものは`aes()`外側に書くが、透明度を調整する引数は`alpha`であり、0に近いほど透明になる。今回は透明度30%（`alpha = 0.3`）を`aes()`の外側に追加する。また、線の太さも太めにしたいので、`geom_line()`の`aes()`の外側に`linewidth`引数を追加して線の太さを調整する。最後に、`geom_line()`と`geom_ribbon()`の順番を変えることで、線が面より上に表示されるようにする（{ggplot2}は後で追加したレイヤーがより上に位置する）。

```{r}
#| filename: "Code 17"
#| fig-width: 8
#| fig-height: 4
inter1_pred |>
  ggplot() +
  geom_ribbon(aes(x = Order, ymin = conf.low, ymax = conf.high,
                  fill = First), alpha = 0.3) +
  geom_line(aes(x = Order, y = estimate, color = First), linewidth = 1) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", 
       color = "", fill = "") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14) +
  theme(legend.position = "bottom")
```

　これで作図は終わったが、2つの幾何オブジェクトが`x`に対して同じマッピングを共有しているため、こちらは`ggplot()`内にマッピングするとより簡潔なコードになる。

```{r}
#| filename: "Code 18"
#| fig-width: 8
#| fig-height: 4
inter1_pred |>
  ggplot(aes(x = Order)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = First), 
              alpha = 0.3) +
  geom_line(aes(y = estimate, color = First), linewidth = 1) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", 
       color = "", fill = "") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw(base_size = 14) +
  theme(legend.position = "bottom")
```

### 予測値（調整変数が連続変数）

　調整変数が連続変数の場合でも同じ手順で可視化する。まずは、{marginaleffects}の`predictions()`で予測値を計算し、表形式オブジェクトとして格納する。ただし、`Duration`の値が2、3、4、...、16の場合の予測値をすべて出してしまうと15本の線（と面）が表示されるため、非常に可読性が落ちてしまう。したがって、ここでは`Duration`の最小値（2）、最大値（16）とその中間である9に固定して予測値を計算する。計算結果は`inter2_pred`に格納する。

```{r}
#| filename: "Code 19"
inter2_pred <- predictions(fit_inter2, newdata = datagrid(Order = 1:10,
                                                          Duration = c(2, 9, 16)))

inter2_pred
```

```{r}
#| filename: "Code 20"
inter2_pred <- inter2_pred |>
  select(Order, Duration, estimate, std.error, conf.low, conf.high)

inter2_pred
```

　続いて、調整変数をfactor化する。`inter2_pred`の`Duration`列は2、9、16の値で構成されており（これは`levels`で指定する）、それぞれ「2年目」、「9年目」、「16年目」とラベルを付ける（これは`labels`で指定する）。

```{r}
#| filename: "Code 21"
inter2_pred <- inter2_pred |>
  mutate(Duration = factor(Duration, levels = c(2, 9, 16), 
                           labels = c("2年目", "9年目", "16年目")))

inter2_pred
```

　最後に{ggplot2}で作図する。使用する幾何オブジェクトはこれまでと同様、`geom_line()`と`geom_ribbon()`だ。

```{r}
#| filename: "Code 22"
#| fig-width: 8
#| fig-height: 4
inter2_pred |>
  ggplot(aes(x = Order)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high, fill = Duration), 
              alpha = 0.3) +
  geom_line(aes(y = estimate, color = Duration), linewidth = 1) +
  labs(x = "出場順番", y = "ファイナルステージへの進出確率", 
       color = "結成からの経過年数", fill = "結成からの経過年数") +
  scale_x_continuous(breaks = 1:10, labels = 1:10) +
  theme_bw() +
  theme(legend.position = "bottom")
```

### 限界効果（調整変数がダミー変数）

　以上の例は{marginaleffects}パッケージの`predictions()`関数を使って**予測値**を計算してきたが、ここからは同じパッケージの`marginaleffects()`関数を使って**限界効果**を計算し、{ggplot2}で可視化する。`marginaleffects()`の場合、**限界効果を計算した変数は`variables`引数に、調整変数はこれまでと同様、`newdata = datagrid()`内に指定**する。限界効果を計算したい変数、つまり交差項の中で調整変数**ではない**ものが主な制つ名変数であり、今回の例だと出場順番（`Order`）である。この変数を`"`を囲み、`variables`に割り当てる。調整変数は初出場ダミー（`First`）が調整変数であれば、`newdata = datagrid()`の`datagrid()`内に`First = 0:1`を割り当てる。計算結果は`inter1_ame`に格納する。

```{r}
#| filename: "Code 23"
inter1_ame <- marginaleffects(fit_inter1, variables = "Order",
                              newdata = datagrid(First = 0:1))

inter1_ame
```

　作図に必要な列（と標準誤差を意味する`std.error`列）を抽出する。一つ注意すべき点は予測値は`estimate`列であったのに対し、限界効果の計算結果には当該列が存在せず、`estimate`列に格納されている点だ。また、限界効果を可視化する際、`Order`の値は不要であるため、省略しても良い。

```{r}
#| filename: "Code 24"
inter1_ame <- inter1_ame |>
  select(First, estimate, std.error, conf.low, conf.high)

inter1_ame
```

　続いて、`inter1_ame`の`First`列をfactor化する。

```{r}
#| filename: "Code 25"
inter1_ame <- inter1_ame |>
  mutate(First = factor(First, levels = 0:1, labels = c("出場経験あり", "初出場")))

inter1_ame
```

　それでは作図してみよう。調整変数が連続変数であれ、ダミー変数であれ、取り得る値が数個程度なら`geom_pointrange()`を使用する。横軸（`x`）は調整変数、縦軸（`y`）は限界効果にし、限界効果の95%信頼区間の下限と上限はそれぞれ`ymin`と`ymax`にマッピングする。また、限界効果の統計的有意性を確認するために、y = 0の箇所に水平線を引く。水平線の幾何オブジェクトは`geom_hline()`であり、`()`内に`yintercept = 0`を入れると、y = 0のところに水平線が表示される。

```{r}
#| filename: "Code 26"
#| fig-width: 3
#| fig-height: 3
inter1_ame |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = First, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "出場経験", y = "出場順番の平均限界効果") +
  theme_bw(base_size = 12)
```

　95％信頼区間内に0が含まれる場合、当該限界効果は統計的に有意でないことを意味する。たとえば、上の図だと初出場の場合のみ、出場順番の限界効果が統計的有意であることが分かる。つまり、「初出場の人の場合、出場順番が遅いほど平均得点が高い傾向がある」と解釈できる。一方、既に出場経験がある場合、出場順番の限界効果が統計的有意ではない。これは、「M-1グランプリの出場経験がある場合、出場順番が遅いほど平均得点が高い傾向がある**とは言えない**」と解釈できる。「〜する傾向はない」ではなく、「〜する傾向があるとは言えない」と解釈する点に注意すること。一般的な統計的有意性検定において「ない」と言い切ることは至難の業である。

### 限界効果（調整変数が連続変数）

　最後に調整変数が連続変数（ここでは`Duration`）の場合について考えてみよう。基本的なやり方はこれまでと同じである。しかし、予測値の可視化の際、`Duration`の値が2、9、16の場合の予測値を計算した。なぜなら、この値が3つでなく、5つになると線の数が増えてしまい、図の可読性が低下するからだ。情報量が多少減っても、可読性の低い図は存在意義がないため、線の本数を減らしたわけだ。しかし、今回の例だと、`Duration`が線の色分けでなく、横軸として使用される。したがって、`Duration`のすべての値を対象に限界効果を計算した方が良い。`datagrid()`内には`Duration = c(1, 2, 3, 4, 5)`と書いても良いが、`Duration = 2:16`の方がより効率的な書き方である。

```{r}
#| filename: "Code 27"
inter2_ame <- marginaleffects(fit_inter2, variables = "Order",
                              newdata = datagrid(Duration = 2:16))

inter2_ame
```

　続いて、作図に必要な列を出力する。今回の場合、連続変数であるため、**factor化は不要**だ。

```{r}
#| filename: "Code 28"
inter2_ame <- inter2_ame |>
  select(Duration, estimate, std.error, conf.low, conf.high)

inter2_ame
```

　続いて作図をする。今回は調整変数が連続変数であるため、線（`geom_line()`）と面（`geom_ribbon()`）の図を出力してみよう。面の透明度指定を忘れないこと（一度、`alpha = 0.3`なしでコードを走らせてみても良いだろう）。

```{r}
#| filename: "Code 29"
#| fig-width: 8
#| fig-height: 4
inter2_ame |>
  ggplot(aes(x = Duration)) +
  geom_hline(yintercept = 0) +
  geom_ribbon(aes(y = estimate, ymin = conf.low, ymax = conf.high),
              alpha = 0.3) +
  geom_line(aes(y = estimate), linewidth = 1) +
  labs(x = "結成からの経過年数", y = "出場順番の平均限界効果") +
  theme_bw(base_size = 14)
```

　今回、`Duration`は2から16まで、つまり14の値で構成されている。この場合、pointrangeプロットを作成しても良いかも知れない。むしろ、結果を解釈する時にはpointrangeプロットの方がやりやすい。

```{r}
#| filename: "Code 30"
#| fig-width: 8
#| fig-height: 4
inter2_ame |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = Duration, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "結成からの経過年数", y = "出場順番の平均限界効果") +
  theme_bw(base_size = 14)
```

　横軸の目盛りを1年刻みに修正してみよう。

```{r}
#| filename: "Code 30"
#| fig-width: 8
#| fig-height: 4
inter2_ame |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = Duration, y = estimate, 
                      ymin = conf.low, ymax = conf.high)) +
  labs(x = "結成からの経過年数", y = "出場順番の平均限界効果") +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  theme_bw(base_size = 14)
```

　限界効果が統計的に有意な箇所は`Duration`の値が4以上、12以下の時である。つまり、「コンビー結成から4年以上、12年以下経過した場合、出場順番が遅いほど平均得点が高い傾向がある」と解釈できる。また、「コンビー結成から3年以下、13年以上経過した場合、出場順番が遅いほど平均得点が高い傾向があるとは言えない」といった解釈もできる。

　おまけに統計的有意性検定の結果も同時に示す方法も紹介する。具体的には限界効果が統計的有意である場合は黒に、非有意である場合はグレーに出力する。コードの説明は割愛するため、興味のある方はぜひコードの中身を解読してみよう。

```{r}
#| filename: "Code 31"
#| fig-width: 8
#| fig-height: 4
inter2_ame |>
  mutate(Sig = if_else(conf.low * conf.high > 0, "Sig", "Insig")) |>
  ggplot() +
  geom_hline(yintercept = 0) +
  geom_pointrange(aes(x = Duration, y = estimate, 
                      ymin = conf.low, ymax = conf.high,
                      color = Sig)) +
  labs(x = "結成からの経過年数", y = "出場順番の平均限界効果") +
  scale_x_continuous(breaks = 2:16, labels = 2:16) +
  scale_color_manual(values = c("Sig" = "black", "Insig" = "gray70")) +
  theme_bw(base_size = 14) +
  theme(legend.position = "none")
```