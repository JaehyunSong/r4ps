---
title: "第8回講義資料"
subtitle: "線形回帰分析（1）"
toc: true
metadata-files: 
  - _material.yml
---

## スライド {.unlisted}

<a href="../../slides/macro/regression1.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../../slides/macro/regression1.html" width="100%" style="aspect-ratio: 16 / 9.2;"></iframe>
```

## 単回帰分析

```{r}
#| include: false
pacman::p_load(tidyverse, gt, summarytools, modelsummary)
beer_df <- read_csv("Data/Beer.csv")
pref_df <- read_csv("Data/PrefData.csv")
```

　まず、今回の実習に必要なパッケージ（{tidyverse}、{summarytools}、{modelsummary}）を読み込み、実習用データを読み込む。単回帰分析の実習用データは`Beer.csv`であり、LMSからダウンロード可能だ。以下のコードは`Beer.csv`がプロジェクト内の`Data`フォルダー内にアップロードされている場合の例である。データの保存先が`Data`フォルダーではない場合、適宜フォルダー名を修正すること。読み込んだデータは`beer_df`という名のオブジェクトとして作業環境内に格納する。

　データを読み込んだら、データの中身を出力する。

```{r}
#| filename: "Code 01"
library(tidyverse)
library(summarytools)
library(modelsummary)

beer_df <- read_csv("Data/Beer.csv")

beer_df
```

　{summarytools}の`descr()`関数を使って記述統計量を出力する。`beer_df`は数値型変数のみで構成されているため、ダミー変数に変換する変数はなく、そのまま`descr()`に渡して良い。

```{r}
#| filename: "Code 02"
beer_df %>%
  descr(stats = c("mean", "sd", "min", "max", "n.valid"),
        transpose = TRUE, order = "p")
```

　今回は気温（`Temperature`）とアサヒスーパードライの販売量（`Beer`）の関係を確認したい。この2つの変数は連続変数であるため、関係性を見る方法としてまず考えられるのが相関分析である。前回講義の内容を参照し、2つの変数の相関係数を統計的有意性検定を行ってみよう（$\alpha = 0.05$を使用）。

```{r}
#| filename: "Code 03"
cor.test(beer_df$Temperature, beer_df$Beer)
```

　相関係数は約0.247であり、（社会科学としては）そこそこ強い正の相関関係だと考えられる。つまり、気温が高い月はビールもよく売れていることを意味する。また、この相関関係は$p$値が約0.040であることから統計的に有意な相関関係とも言えよう。しかし、もう一つ知りたいことがある。それは「気温が1度上がればビールはどれほどもっと売れるか」である。相関係数はこの問いに対する答えを提供しない。ここで回帰分析と出番である。回帰分析は変数間の関係が線形関数で説明できると**仮定**する（線形性の仮定）。$x$の変動による$y$の変動は$y = \alpha + \beta \times x$のような一次関数として表現することができ、ここでの$x$が気温、$y$がアサヒスーパードライの販売量である。回帰分析はこの一次関数の切片（$\alpha$）と傾き（$\beta$）を推定する手法である。

:::{.callout-note}
## もう少し詳しく!

　線形回帰分析の場合、切片と傾き以外にももう一つ推定対象があり、それは誤差項の分散（$\sigma$）である。また、切片と傾きは$\alpha$、$\beta$でなく、$\beta_0$、$\beta_1$と表記するケースもある。
:::

　一次関数の切片と傾きがわかれば以下のような直線（=**回帰直線**）を描くことができる。

```{r}
#| filename: "Code 04"
#| fig-width: 10
#| fig-height: 6
beer_df %>%
  ggplot(aes(x = Temperature, y = Beer)) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(x = "気温 (摂氏)", y = "アサヒ・スーパードライ販売量 (万箱)") +
  theme_bw(base_size = 16)
```

　この回帰直線ってどのように決まるだろうか。それは**残差の二乗和が最小化されるような直線**である。残差とは任意の直線を引いた際、各点（観測値）と直線間の距離を意味する。**観測値と直線間の距離は最短距離でなく、横軸に対して垂直方向の距離であることに注意**すること（以下の図を参照）。ただし、この残差には符号が存在し、正と負が相殺される。したがって、全て正にするために残差を二乗する（絶対値を使うこともできるが、微分が大変なので使われない）。

```{r}
#| echo: false
#| fig-width: 10
#| fig-height: 6
beer_df %>%
  #filter(Year == 2020, Beer >= 400, Beer <= 780) %>%
  #mutate(Pred = 406.50 + 7.19 * Temperature) %>%
  mutate(Pred = 576.227 + 7.355 * Temperature) %>%
  select(Year, Month, Temperature, Beer, Pred) %>%
  ggplot(aes(x = Temperature, y = Beer)) +
  geom_segment(aes(x = Temperature, xend = Temperature,
                   y = Beer, yend = Pred), linetype = 2) +
  geom_point(size = 3) +
  geom_smooth(method = "lm", se = FALSE) +
  labs(x = "気温 (摂氏)", y = "アサヒ・スーパードライ販売量 (万箱)") +
  theme_bw(base_size = 16)
```

　この直線の切片と傾きはR内臓の`lm()`関数で簡単に計算できる。第一引数は回帰式であり、`応答変数 ~ 説明変数`と書く。第二引数は`data`であり、回帰式に登場した変数が格納されているデータのオブジェクト名を指定する。今回の回帰式は`Beer ~ Temperature`であり、この2つの変数は`beer_df`にあるため、`data = beer_df`と指定する。推定結果は何らかの名前を付けて作業スペース内に格納する必要があるが、今回は`beer_fit`と名付ける。推定結果を出力する際は`summary()`関数を使用すること。

```{r}
#| filename: "Code 05"
beer_fit <- lm(Beer ~ Temperature, data = beer_df)

summary(beer_fit)
```

　`(Intercept)`は切片を、その以下の行は各変数の傾きを意味する。点推定値は`Estimate`列である。切片は約576.227、気温の傾きは7.355であることから以下のような関係が分かる。

<center>
アサヒスーパードライ販売量の**予測値** = 576.227 + 7.355 $\times$ 気温

</center>

　これは「`Temperature`が1上がると、`Beer`の値が平均的に7.355上がる」ことを意味する。`Temperature`の1は1度、`Beer`の1は1万箱であるため、これをより自然な形で解釈すると、「気温が1**度**上がると、アサヒスーパードライの販売量は平均的に約7.355**万箱**上がる」となる。また、気温とビールの販売量間の関係が統計的に有意な関係かを確認するためには、傾きの統計的有意性検定が必要である。帰無仮説は「傾きは0である（=関係がない）」であり、今回得られた$p$値は約0.040であることから、統計的に有意な関係があると考えられる。もし、$p \geq 0.05$の場合は、「気温とビール販売量の間には統計的に有意な関係があるとは言えない」、または「気温とビール販売量の間には統計的に有意な関係が確認できない」こととなる。

:::{.callout-note}
## 予測値 $\neq$ 観測値

推定の結果、回帰式は「アサヒスーパードライ販売量の**予測値** = 576.227 + 7.355 $\times$ 気温」のようになる。ここで注意すべき点は「予測値」だ。たとえば、2016年5月の場合、気温は20.2度である。これを代入すると「576.227 + 7.355 $\times$ 20.2 $\simeq$ 725」、つまり725万箱であり、これが**予測値**である。しかし、実際の販売量（**観測値**）は794万箱であり、約69万箱の差が存在する。この69万箱が2016年5月の**残差**であり、回帰分析はこの残差を最小化するような直線を推定する手法である。2つの変数間の相関係数が1、または-1でない限り、残差が0になることはない。
:::

　本モデルの説明力は決定係数から確認できる。Rの場合、デフォルトで2種類の決系係数が出力される。`Multiple R-squared`が通常の決定係数、`Adjusted R-squared`が自由度調整済み決定係数である。通常の決定係数は説明変数が増えると必ず大きくなるため、モデルのパフォーマンスの判断材料としては望ましくないとされる。一般的に、モデルはシンプルであるほど良い（オッカムの剃刀）と考えられるため、多少決定係数が小さくても説明変数の少ない方が良いモデルとされる。一方、自由度調整済み決定係数は説明変数が増えると決定係数にペナルティーを課するため、こちらの方がより適切である。いずれの決定係数も0以上1以下の値を取り、1に近いほど説明力の高いモデルであるとされる。

## 重回帰分析

　以上の例のように、説明変数が1つのみの回帰分析は「単回帰分析」と呼ばれる。しかし、実際のデータ分析の場面において、ある応答変数を1つの変数だけで説明することは滅多になく、複数の説明変数を回帰式に投入する。このように説明変数が2つ以上の回帰分析を「重回帰分析」と呼ぶ。以下では重回帰分析の実装、解釈、モデル間の比較について解説する。

　まず、実習に必要なデータを読み込む。重回帰分析の実習用データは`PrefData.csv`であり、LMSからダウンロード可能だ。以下のコードは`PrefData.csv`がプロジェクト内の`Data`フォルダー内にアップロードされている場合の例である。データの保存先が`Data`フォルダーではない場合、適宜フォルダー名を修正すること。読み込んだデータは`pref_df`という名のオブジェクトとして作業環境内に格納する。

　データを読み込んだら、データの中身を出力する。

```{r}
#| filename: "Code 06"
pref_df <- read_csv("Data/PrefData.csv")

pref_df
```

　分析の前にデータの記述統計量を出力する。今回は各行の番号（`ID`）と都道府県名（`Pref`）列の記述統計量は不要であるため、`descr()`関数に渡す前に2つの列を除外する。

```{r}
#| filename: "Code 07"
pref_df %>%
  select(-c(ID, Pref)) %>%
  descr(stats = c("mean", "sd", "min", "max", "n.valid"),
        transpose = TRUE, order = "p")
```

　ここでは「都道府県の財政力指数（`Zaisei`）が自民党得票率（`Jimin`）に与える影響」を調べるとし、まずは単回帰分析を実装する。

<center>
自民党の得票率の予測値 = $\alpha$ + $\beta \times$ 財政力指数

</center>

　推定結果は`jimin_fit1`という名のオブジェクトとして作業環境内に格納し、`summary()`関数で推定結果を確認しよう。

```{r}
#| filename: "Code 08"
jimin_fit1 <- lm(Jimin ~ Zaisei, data = pref_df)

summary(jimin_fit1)
```

　推定結果から以下のような一次関数が得られた。

<center>
自民党の得票率の予測値 = 45.291 - 13.012 $\times$ 財政力指数

</center>

　これは「財政力指数が1上がると、自民党の得票率の予測値は約13.012%p下がる」ことを意味し、この関係は統計的に有意である（$p$ = 0.001）。

　ここで注意すべき点が2つある。1点目は**係数の符号**である。今回得られた`Zaisei`の傾き係数は負（マイナス）である。したがって、解釈の際は「$x$が上がると、$y$は下がる」と解釈する必要がある。2点目は**予測値の単位**だ。`Jimin`変数の場合、単位は「%（パーセント）」であるが、解釈の際は「%p（パーセントポイント）」となる。たとえば、財政力指数が0の都道府県の場合、自民党得票率の予測値は45.291%である。一方、財政力指数が1の場合のそれは32.279%だ。財政力指数が1あがったところで自民党得票率は45.291%から32.279%へ下がる。つまり、「45.291% - 32.279%」分下がるということであるが、この場合「13.012**%**下がる」と解釈してはいけない。正しい解釈は「13.012**%p**下がる」だ。この2つには大きな違いがある。たとえば、得票率が20%から40%へ上昇した場合の解釈は「100**%**上がる」か「20**%p**上がる」どっちかである。「%」の差分は「%」でなく「%p」であることに注意すること。

　話を戻そう。我々は「原因以外の重要な要因」を考慮する必要があることを既に知っている（リサーチデザインの講義資料を参照）。とりわけ、$y$に影響を与えそうな要因の中には、$x$にも影響を与えそうな要因もある。この第3の変数を$z$と呼ぼう。

```{r}
#| echo: false
#| message: false
#| dpi: 150
#| fig-width: 4
#| fig-height: 2.5
pacman::p_load(dagitty, ggdag)

dagify(X ~ Z,
       Y ~ X + Z,
       exposure = "X",
       outcome  = "Y",
       coords   = list(x = c(X = 1, Y = 3, Z = 2),
                  y = c(X = 1, Y = 1, Z = 2))) %>%
  ggdag(node_size = 9, text_size = 7) +
  coord_cartesian(ylim = c(0.5, 2.5)) +
  theme_dag_blank()
```

　この$z$に該当する変数は無限に存在するが、手元のデータ（`pref_df`）内の変数が限られている。それでも出来る限り、手元も変数を最大限活用したい。たとえば、65歳以上人口の割合（`Over65`）はどうだろうか。基本的に高齢者が多い地域ほど財政力指数が低い傾向がある。また、政治学では高齢者ほど政治的に保守的イデオロギーを持つとも言われている（加齢効果）。したがって、65歳以上人口の割合（`Over65`）は$z$に該当すると考えられる。このような$z$は回帰分析の説明変数として加える必要がある。

　それでは先程の単回帰モデルに65歳以上人口の割合（`Over65`）を加えた以下の回帰モデルを推定する。

<center>
自民党の得票率の予測値 = $\alpha$ + $\beta_1 \times$ 財政力指数 + $\beta_2 \times$ 65歳以上人口の割合

</center>

　推定対象は$\alpha$と$\beta_1$、$\beta_2$である。実装の方法は単回帰分析と同じであり、説明変数を`+`でつなぐだけである。推定結果は`jimin_fit2`という名のオブジェクトとして作業環境内に格納し、`summary()`関数で推定結果を確認しよう。

```{r}
#| filename: "Code 09"
jimin_fit2 <- lm(Jimin ~ Zaisei + Over65, data = pref_df)

summary(jimin_fit2)
```

　推定結果から以下のような一次関数が得られた。

<center>
自民党の得票率の予測値 = 15.891 - 4.547 $\times$ 財政力指数 + 0.881 $\times$ 65歳以上人口の割合

</center>

　以上の結果を解釈すると「**65歳以上人口の割合が同じである場合**、財政力指数が1上がると、自民党の得票率の予測値は約4.547%p下がる」となる。

　ここでも解釈の際、2つの注意点がある。1点目は**変数の統制**である。重回帰分析の結果を解釈する際は、解釈の対象とする変数以外の変数の値が同じあることを意識する必要がある。「65歳以上人口の割合の効果を除いた財政力指数の影響」とも言えよう。このような統制変数によって係数の大きさも変わりうる。実際、単回帰分析では-13.012だった点推定値が-4.547となった。これは単回帰分析から得られた-13.012%pという効果には、実際のところ、65際以上人口の割合の効果が混ざっていたことを意味する。2点目は**統計的有意性**である。今回の例だと`Zaisei`の係数の$p$値は約0.351となり、0.05を上回る。単回帰分析とは違って、`Zaisei`と`Jimin`の間には統計的に有意な関係があるとは言えないこととなる。したがって、正しい解釈は「他の変数が同じである場合、財政力指数と自民党の得票率の間には統計的に有意な関係があるとは言えない」、あるいは「他の変数が同じである場合、財政力指数が1上がると、自民党の得票率の予測値は約4.547%p下がるものの統計的に有意な関係があるとは言えない」となる。

　説明変数はもっと増やすこともできる（厳密には$n-1$個まで投入できる）。たとえば、当該都道府県の第一次産業の割合（`Primary`）はどうだろうか。自民党の固い支持基盤としての農協（JA）、そして財政力指数の大きい部分を製造業（第二次産業）、サービス業（第三次産業）が占めることを考えると、これもまた「第3の変数」であろう。先程の`jimin_fit2`モデルに`Primary`を追加したモデルも推定してみよう。

```{r}
#| filename: "Code 10"
jimin_fit3 <- lm(Jimin ~ Zaisei + Over65 + Primary, data = pref_df)

summary(jimin_fit3)
```

　推定結果から以下のような一次関数が得られた。

<center>
自民党の得票率の予測値 = 15.914 - 4.631 $\times$ 財政力指数 + 0.883 $\times$ 65歳以上人口の割合 - 0.008 $\times$ 第一産業従事者の割合

</center>

　これまで3つのモデルを推定してきたが、モデル間の比較する際には{modelsummary}パッケージが便利だ。{modelsummary}の`modelsummary()`関数の第一引数として推定結果のオブジェクトを`list()`でまとめて入れるだけである。

```{r}
#| filename: "Code 11"
# ない場合はinstall.packages("modelsummary")でインストール
library(modelsummary) 
modelsummary(list(jimin_fit1, jimin_fit2, jimin_fit3))
```

　カッコで囲まれている数値は標準誤差（Standard Error; SE）である。一般的な学術論文では$p$値よりも標準誤差の掲載が一般的である（標準誤差から$p$値の計算は簡単だが、その逆は面倒だから）。もし、標準誤差の代わりに$p$値を掲載する場合は以下のようにコードを修正する（`statistic`引数の追加）。また、`coef_rename`引数で変数名の任意の文字列に変更することも出来、`notes`引数で注を付けることもできる。

```{r}
#| filename: "Code 12"
modelsummary(list(jimin_fit1, jimin_fit2, jimin_fit3),
             statistic   = "({p.value})",
             coef_rename = c("(Intercept)" = "切片",
                             "Zaisei"      = "財政力指数",
                             "Over65"      = "65歳以上人口の割合",
                             "Primary"     = "第一次産業従事者の割合"),
             notes       = "注: カッコ内はp値")
```

　自由度調整済み決定係数は「R2 Adj.」行から確認できる。最も高いモデルは財政力指数と65歳以上人口の割合のみに構成されて2番目のモデル（`jimin_fit2`）である。第一次産業従事者の割合まで追加した3番目のモデルは、やや低い決定係数が得られた。追加された「第一次産業従事者の割合」の係数が非常に小さく、統計的に有意な関係も見られない。つまり、どちらかの言えば「不要（$\simeq$あっても良いが、入れて得することもない）」に近い変数であることを意味する。説明力が同じであれば、説明変数は少ないことに越したことはないので、モデル2がより望ましいと評価できよう。