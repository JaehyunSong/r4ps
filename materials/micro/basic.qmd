---
title: "第3回講義資料"
subtitle: "Rの基本的な操作"
toc: true
metadata-files: 
  - _material.yml
---

## スライド {.unlisted}

<a href="../../slides/micro/basic.html" class="btn btn-primary btn-sm" target="_blank" role="button"><i class="bi bi-window"></i> 新しいタブで開く</a>

```{=html}
<iframe class="slide-deck" src="../../slides/micro/basic.html" width="100%" style="aspect-ratio: 16 / 9.5;"></iframe>
```

## 電卓としてのR

```{r}
#| include: false
rm(has_annotations)
```

**手順1:** File > New File > R Scriptをクリックする。

![](Figs/basic/Script_1.png){width=75% fig-align="center"}

**手順2:** Sourceペインのペイン最大化ポタンをクリックし、Sourceペインの大きさ最大化する。

![](Figs/basic/Script_2.png){width=75% fig-align="center"}

**手順3:** Sourceペインに以下の内容を入力する。

```{r}
#| filename: "Code 01"
#| eval: false
1 + 1
```

**手順4:** コードの行にカーソルをおいたままControl（Ctrl）とEnterを同時に押す（大学のWindows PCの場合）。これはカーソルが位置する行のコードを実行するキーである。このキーは使用するOSによって異なる。

| OS             | キー                       | 解説                     |
|:---------------|:---------------------------|:-------------------------|
| macOS          | {{< kbd Command-Return >}} | Command（Cmd） + Return  |
| Linux（Ubuntu）| {{< kbd Ctrl-Return >}}    | Control（Ctrl）+ Return  |
| Windows        | {{< kbd Ctrl-Enter >}}     | Control（Ctrl）+ Enter   |

:::{.callout-note}
## カーソルって...?

カーソル (cursor)とは文字の入力位置を意味する。RStudioのテーマによって色は異なるが、Sourceペイン、またはConsoleペインなど、何らかの文字が入力できる箇所において点滅する「`|`」がカーソルです。
:::

**手順5:** Consoleペインに結果が表示される。

```{r}
#| echo: false
1 + 1
```

　これくらいの計算はConsoleペインで直接打ち込んでも良いが、自分がこれまで書いたコードを残すという意味でSourceペインに入力することを推奨する。R Scriptを保存しておけばいつでも開いて前回のコードを再現できる。

## コメント

　Rのスクリプトを作成する際、何かのメモを書いておきたいケースが多々ある。コードが長くなったり、複雑になったりすると、自分が書いたコードでも意味がよく分からないケースも多く発生する。これはデータ分析のプロでも例外でなく、宋も同じである。この場合、スクリプト内にこまめにメモを書いておくと、このコードが何のためのコードかなどが素早く把握できる。

　Rにおけるコメントは`#`を使用する。同じ行における`#`以降の内容は処理に影響を与えない。たとえば、以下のコードだと`# 12345と12345の積`は処理に影響を与えない

```{r}
#| filename: "Code 02"
# 12345と12345の積
12345 * 12345
```

　また、コードと同じ行にコメントを書くこともできる。

```{r}
#| filename: "Code 03"
12345 * 12345 # 12345と12345の積
```

　コードにこまめにコメントを書くのは意外と面倒な作業であるが、コメントに「書きすぎ」は存在しない。書けば書くほど未来の自分から感謝されるだろう。

## 算術演算子

　算術演算子は数字と数字の間に入力し、結果として何らかの**数字**が返される演算子である。先ほどの`+`や`*`も算術演算子（足し算と掛け算）である。ここでは良く使う算術演算子7つを紹介する。

| 演算子    | 意味            | 例                  | 結果 |
|:---------:|-----------------|---------------------|-----:|
| `+`       | 和              |`2 + 5`              |  7   |
| `-`       | 差              |`2 - 8`              | -6   |
| `*`       | 積              |`7 * 3`              | 21   |
| `/`       | 商              |`16 / 5`             |  3.2 |
| `^`、`**` | 累乗（べき乗）  | `2^3`または`2 ** 3` |  8   |
| `%%`      | 剰余 (モジュロ) | `18 %% 7`           |  4   |
| `%/%`     | 整数商          | `18 %/% 7`          |  2   |

　例を見てみよう。

```{r}
#| filename: "Code 04"
1 + 5  # 足し算
```

```{r}
#| filename: "Code 05"
3 - 10 # 引き算
```

```{r}
#| filename: "Code 06"
19 * 2 # 掛け算
```

```{r}
#| filename: "Code 07"
13 / 7 # 割り算
```

```{r}
#| filename: "Code 08"
5^3    # 5の3乗
```

　これは義務ではないがないが、累乗（`^`）を除き、演算子の前後にはスペースを入れるのがRの流儀であり、コードが読みやすくなる。以下のコードを比べてみよう。

```{r}
#| filename: "Code 09"
# 読みにくい例
(((3+5)*4)+((5%%2)+3))^2
```

```{r}
#| filename: "Code 10"
# 読みやすい例
(((3 + 5) * 4) + ((5 %% 2) + 3))^2
```

　結果は同じだが、後者の方が読みやすいだろう。これから紹介する論理演算子でも共通する内容であるが、「累乗（`^`）を除き、演算子の前後にはスペースを入れる」ことを覚えておこう。ちなみにカッコ（`(`と`)`）は演算子ではないため、スペースは不要である。

## 論理演算子

　算術演算子は結果として数値が返ってくるが、論理演算子は真（`TRUE`）か偽（`FALSE`）のいずれかの値を返す演算子である。ここではまず、大小関係を判定する論理演算子を紹介する。

|演算子  |意味                      |例                              |結果   |
|--------|--------------------------|--------------------------------|-------|
|`x < y` |`x`は`y`より小さい        |`3 < 1`                         |`FALSE`|
|`x <= y`|`x`は`y`と等しいか、小さい|`2 <= 2`                        |`TRUE` |
|`x > y` |`x`は`y`より大きい        |`6 > 5`                         |`TRUE` |
|`x >= y`|`x`は`y`と等しいか、大きい|`4 >= 5`                        |`FALSE`|
|`x == y`|`x`と`y`は等しい          |`(2 + 3) == (4 + 1)`            |`TRUE` |
|`x != y`|`x`と`y`は等しくない      |`((2 * 3) + 1) != (2 * (3 + 1))`|`TRUE` |

　一つ注意すべき点は「等しい」を意味する論理演算子は`=`でなく、`==`だということだ[^equal-operator]。

[^equal-operator]: 他のプログラミング言語の経験があれば分かるだろうが、ほとんどのプログラミング言語において`=`は「代入」を意味し、Rも例外ではない。ただし、Rにおける代入には`=`と`<-`の2つの方法があり、後者が推奨される。

```{r}
#| filename: "Code 11"
3 > 2 # 3は2より大きいの?
```

```{r}
#| filename: "Code 12"
5 <= 10 # 5は10と同じか小さいの?
```

```{r}
#| filename: "Code 13"
2 + 3 == 1 # 2と3の和は1なの?
```

```{r}
#| filename: "Code 14"
2 + 2 != 2 * 2 # 2と2の和は2と2の積と同じなの?
```

　算術演算子は一行に何回も使えるが、通常、論理演算子は一行に一つしか使えない。複数の論理演算子を使うためには、`&`（AND演算子）と`|`（OR演算子）を使う必要がある。

　AND演算子`&`は、`&`を挟む左右の**両側**が`TRUE`の場合のみ`TRUE`を返す演算子である。

```{r}
#| filename: "Code 15"
(2 + 3 == 5) & (2 * 3 == 5) # TRUE and FALSEだから... FALSE!
```

```{r}
#| filename: "Code 16"
(2 + 3 == 5) & (2 * 3 == 6) # TRUE and TRUEだから... TRUE!
```

　OR演算子`|`は、`|`を挟む左右の**片側、あるいは両側**が`TRUE`の場合のみ`TRUE`を返す論理演算子である。

```{r}
#| filename: "Code 17"
(2 + 3 == 5) & (2 * 3 == 5) # TRUE or FALSEだから... TRUE!
```

```{r}
#| filename: "Code 18"
(2 + 3 == 5) & (2 * 3 == 6) # TRUE or TRUEだから... TRUE!
```

```{r}
#| filename: "Code 19"
(2 + 3 == 6) & (2 * 3 == 5) # FALSE or FALSEだから... FALSE!
```

　論理演算子には他にもいくつかあるが、説明は割愛する。

* `!`: 否定演算子（`TRUE`なら`FALSE`、`FALSE`なら`TRUE`が返ってくる。意外と良く使う）
* `&&`: `&`と同じ
* `||`: `|`と同じ
* `xor()`: 排他的論理和（`xor(FALSE, TRUE)`と`xor(TRUE, FALSE)`の場合のみ`TRUE`が返ってくる。論理回路に興味あれば重要な演算子だが、実際に使うケースはあまりない。）

　論理演算子が活躍するのはデータ加工（データハンドリング）の時である。何かの条件を指定して、その行件に合致するケースのみを抽出する場合は、これらの論理演算子の使用が必須である。

:::{.callout-tip}
## マッチング演算子: `%in%`

　もう一つ便利な論理演算子としてマッチング演算子`%in%`がある。これについてはデータハンドリングの講義で解説する。
:::

## 代入とベクトル

　まず、以下のような例を考えてみよう。

* 123454321 $\times$ 2を計算してみよう
* 123454321 $\times$ 3を計算してみよう
* 123454321 $\times$ 4を計算してみよう
* ...
* 123454321 $\times$ 200を計算してみよう

```{r}
#| filename: "Code 20"
#| eval: false
123454321 * 2
123454321 * 3
123454321 * 4

(省略)

123454321 * 198
123454321 * 199
123454321 * 200
```

　このように199行のコードを書く必要がある。もう少し効率的な方法はないだろうか。まず、この`123454321`を書く手間をなんとかしてみよう。

* **方法1:** `123454321`をコピーし貼り付けながら計算を繰り返す
* **方法2:** `123454321`に`x`という名前を付けて、`x * 1`のように表記する（**ここが重要**）

　いずれも有効な方法であるが、方法1には致命的なデメリットがある。それは修正が面倒だという点である。もし「あ、ごめん！123454321じゃなくて、23235211だったわ！コード直してもらえる？」と言われたら、199行のコードをすべて修正する必要がある。一方、方法2を使えば、「`123454321`に`x`という名前を付ける」コードのみを修正すれば良い。このように何かの数字、文字列などに名前を付けて後から使えるようにする作業を**代入**（assignment）と呼ぶ。


### ベクトル

　代入の話をする前にRにおけるデータ構造の一種である**ベクトル**（vector）の話をしなければならない。ベクトルは**Rにけるデータの最小単位**である。Rには様々なデータ構造があるが、これらはすべてベクトルの集合と言っても過言ではない。このベクトルには以下のような特徴がある。

**ベクトルの特徴**

* ベクトルの長さは1以上である。
  * `1`や`"Cat"`は長さ1のベクトル
  * 長さ1のベクトルは原子ベクトル（atomic vector）とも呼ばれる。
* 一つのベクトル同じデータ型（数値、文字列など）で構成される。
  * 数値と文字列が混在するベクトルは作成できない。

:::{.callout-note}
## データ型? データ構造?

　データ**型**とデータ**構造**については今後の講義で解説する。
:::

　まずはこの2つだけ覚えておけば問題ない。重要なのはベクトルの作り方であるが、長さ1のベクトルであれば、`1`、`"Cat"`などで十分である。もし、ながさ2以上のベクトルを作る場合は`c()`関数を使う。`()`内にコンマ区切りの要素 (element)を入れるだけである。

```{r}
#| filename: "Code 21"
19861008 # 長さ1の数値型ベクトル
```

```{r}
#| filename: "Code 22"
c(1986, 10, 8) # 長さ3の数値型ベクトル
```

:::{.callout-tip}
## `,`の後にはスペースを入れよう！

　コードの可読性の観点から見ると、`c(1986,10,8)`より`c(1986, 10, 8)`の方が読みやすい。
:::

### ベクトル同士の計算

　それでは、（原子ベクトルを含む）ベクトルに名前を付ける方法について紹介する。それは代入演算子`<-`である。`x <- 123454321`は`x`という器に`123454321`という数字を入れることを意味する。ここでいう「器」のことを**オブジェクト**（object）と呼ぶ。オブジェクトに関する説明は今後の講義で解説する。オブジェクトの内容を確認するためにはオブジェクトの名前のみを入力する。

```{r}
#| filename: "Code 23"
x <- 123454321 # xに123454321を代入
x
```

　先ほどの作業は以下のように簡略化することができる。

```{r}
#| filename: "Code 24"
#| eval: false
x <- 123454321 # xに123454321を代入
x * 2
x * 3
x * 4

(省略)

x * 198
x * 199
x * 200
```

　これを使えば、もし修正要請があったとしても`x <- 123454321`の部分だけ修正すれば良いだろう。ただ、それでも200行のコード（代入で1行、計算で199行）を書くことには代わりがない。これをなんとか出来ないだろうか。以上のコードは1〜3行にまとめることができる。そのためにベクトル同士の計算について考える必要がある。同じ長さのベクトル同士の計算の場合、同じ位置の要素同士の計算が行われる。以下の例を考えてみよう。

```{r}
#| filename: "Code 25"
my_vec1 <- c(1, 2, 3, 4, 5, 6)
my_vec2 <- c(0, 1, 2, 0, 1, 2)
my_vec1 * my_vec2
```

　上記のコードは以下のように表すことができる。

|ベクトル/位置|1番目|2番目|3番目|4番目|5番目|6番目|
|---|:---:|:---:|:---:|:---:|:---:|:---:|
|`my_vec1`|1|2|3|4|5|6|
||$\times$|$\times$|$\times$|$\times$|$\times$|$\times$|
|`my_vec2`|0|1|2|0|1|2|
|結果|0|2|6|0|5|12|

　もし、ベクトルの長さが一致しない場合はどうなるだろうか。この場合、短い方のベクトルが繰り返されることとなり、これを**ベクトル・リサイクル**（vector recycle）と呼ぶ。以下の例では`my_vec4`の方が短いため、`3 * 2`までの計算が終わったあと、もう一回`my_vec4`の1番目の要素、`0`が使われることになる。

```{r}
#| filename: "Code 26"
my_vec3 <- c(1, 2, 3, 4, 5, 6)
my_vec4 <- c(0, 1, 2)
my_vec3 * my_vec4
```

　このベクトル・リサイクルを利用すれば簡単に199行のコードを簡略化できよう。ただし、2から200まで格納されている長さ199のベクトルを作るのが面倒かも知れない。2, 3, 4, ..., 199, 200は公差1の等差数列であり、Rでは`seq()`関数を使うことで等差数列を簡単に作ることができる。たとえば、2から10までの公差1の等差数列であれば、以下のように作れる。

```{r}
#| filename: "Code 27"
seq(2, 10, by = 1) # 2から10までの公差1の等差数列
```

　公差1でなく公差2であれば、`by = 1`を`by = 2`に修正する。

```{r}
#| filename: "Code 28"
seq(2, 10, by = 2) # 2から10までの公差2の等差数列
```

　また、公差1の等差数列であれば、`:`演算子を使うこともできる。

```{r}
#| filename: "Code 29"
2:10 # 2から10までの公差1の等差数列
```

　これで199行のコードを簡略化する準備は整った。まずは3行に簡略化した例を見てみよう。

```{r}
#| filename: "Code 30"
# 3行の例
x <- 123454321
y <- 2:200 # または、y <- seq(2, 200, by = 1)
x * y
```

　これを2行にまとめる場合は、`x`と`y`いずれかをベクトルとして格納し、もう片方は格納せずそのまま計算に使う（結果は省略）。

```{r}
#| filename: "Code 31"
#| eval: false
# 2行の例 (1)
x <- 123454321
x * 2:200
```

```{r}
#| filename: "Code 32"
#| eval: false
# 2行の例 (2)
x <- 2:200
123454321 * x
```

　究極のやり方は`x`も`y`も格納せずそのまま使う方法であり、これなら1行にまとめることができる（結果は省略）。

```{r}
#| filename: "Code 33"
#| eval: false
# 1行の例
123454321 * 2:200
```

### 要素の抽出

　最後にベクトルから任意の要素を抽出する2つの方法について紹介する。

**方法1**: 抽出する要素の位置を指定する。

　要素の抽出する基本的な方法は`ベクトル名[抽出する要素の位置]`である。たとえば、`my_vec5`という11から20までの公差1の等差数列のベクトルがあるとする。

```{r}
#| filename: "Code 34"
my_vec5 <- 11:20 # my_vec <- seq(11, 20, by = 1) と同じ
my_vec5
```

　この`my_vec5`から3番目の要素は13であり、この値を抽出するためには`my_vec5[3]`と入力する。

```{r}
#| filename: "Code 35"
my_vec5[3]
```

　複数の要素を抽出したい場合は、`[]`内にベクトルを入れる。たとえば、`my_vec5`から2、3、4、5番目の要素を抽出する場合は、`[]`内に`c(2, 3, 4, 5)`を入力する。

```{r}
#| filename: "Code 36"
my_vec5[c(2, 3, 4, 5)] # my_vec5[2, 3, 4, 5]でないことに注意
```

　この`c(2, 3, 4, 5)`は2から5までの公差1の等差数列であるため、`c(2, 3, 4, 5)`の代わりに`seq(2, 5, by = 1)`を使用しても良い。

```{r}
#| filename: "Code 37"
my_vec5[seq(2, 5, by = 1)]
```

　むろん、公差1の等差数列を使う`:`を使用し、`[]`内に`2:5`を指定した方がより効率的であろう。

```{r}
#| filename: "Code 38"
my_vec5[2:5]
```

**方法2**: 論理演算子を利用する。

　もう一つは`[]`内に`TRUE`か`FALSE`を入れる方法である。位置を指定する方法では抽出したい要素の位置のみを指定するだけだったが、この方法は、すべての要素に対して抽出するか（`TRUE`）しないか（`FALSE`）を指定する必要がある。つまり、元のベクトルの長さと`[]`内に指定するベクトルの長さは一致する必要がある。たとえば、`my_vec5`の1、4、7、9、10番目の要素を抽出したい場合は`my_vec5[c(1, 4, 7, 9, 10)]`でも良いが、以下のように抽出する箇所に`TRUE`、抽出しない箇所に`FALSE`を指定することもできる。

```{r}
#| filename: "Code 39"
# 1、4、7、9、10番目がTRUEで、他は全てFALSE
my_vec5[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE)]
```

　`[]`内にベクトルの長さ分のベクトルを更に入力する必要がある。`my_vec5`のように長さ10のベクトルなら問題ないだろうが、長さが数千のベクトルも稀ではない（むしろ実際のデータ分析だと数百以上が当たり前となる）。これを考えると、一つ一つの要素に対して`TRUE`、`FALSE`を指定することは非常に非効率的である。

　しかし、我々は論理演算子を使えば`TRUE`、または`FALSE`のベクトルを作れることをすでに知っている。たとえば、`my_vec5`から奇数のみを抽出したいとする。奇数は2で割って1が余る数字である。余りを計算する算術演算子は`%%`であり、この余りが1かどうかを判定すれば良い。

```{r}
#| filename: "Code 40"
my_vec5 %% 2 == 1
```

　`my_vec5`を構成する全ての要素に対して、奇数か偶数かの判定結果がベクトルとして返ってくることが分かる。この論理演算子が含まれた判定文を`[]`内に入れることで、`my_vec5`から奇数のみを抽出することができる。

```{r}
#| filename: "Code 41"
my_vec5[my_vec5 %% 2 == 1]
```

　むろん、これまでの通り`my_vec5 %% 2 == 1`を別途のベクトルとして格納した上で、そのベクトルを`[]`に入れても良い。

## 表データの読み込み

　データ分析に用いられるデータの形式は表、文字列、画像、音声など様々であるが、本講義では表形式のデータ（rectangular data）のみを扱う。ここでは表形式データの読み込み方法について紹介する。表形式データにはエクセル形式（`.xlsx`）がお馴染みであろうが、データ分析の業界においてはカンマ区切る形式（`.csv`）が標準である。

　csvファイルの読み込みにはR内蔵関数`read.csv()`関数が使えるが、本講義では{tidyverse}パッケージが提供する`read_csv()`関数を使用する。データ読み込みの前にまず{tidyverse}パッケージを読み込む。

```{r}
#| filename: "Code 42"
library(tidyverse)
```

　読み込み方法は`read_csv("読み込むファイルのパス")`である（パスの概念については「[ファイルシステム](../../intro/filesystem.html){target="_blank"}」を参照すること）。プロジェクト・フォルダー内に`Data`フォルダーがあり、そこに`Pref_Vote.csv`というファイルがあれば、`read_csv("Data/Pref_Vote.csv")`となる。もし、プロジェクト・フォルダー直にデータが入っているのであれば、`read_csv("Pref_Vote.csv")`となる。ただし、`read_csv()`だけだとデータの中身が出力されるだけであり、作業環境内に格納されない。代入演算子`<-`を使って作業環境内にデータを入れておく必要がある。ここでは読み込んだデータを`my_data`という名の新しいオブジェクトに格納する。

```{r}
#| filename: "Code 43"
# 以下のデータはLMSから入手可能
my_data <- read_csv("Data/Pref_Vote.csv")
```

　ちなみに現在の作業環境内に、どのようなオブジェクトが存在するかを確認するためにはConsoleペイン上で`ls()`を入力する[^ls]。

[^ls]: 実は数千以上のオブジェクトがあるはずだが、ここでは自分が作成したオブジェクトのみ表示される。

```{r}
#| filename: "Code 44"
ls()
```

　問題なく`my_data`というオブジェクトが生成されていることが分かる。それではデータの中身を確認してみよう。

```{r}
#| filename: "Code 45"
my_data # または、print(my_data)
```

　この画面からデータの中身以外にもいくつかの情報が読み取れる。たとえば、1行目には以下のような内容が入っている。

```
# A tibble: 47 × 16
```

　これは47行16列のデータであることを意味する。しかし、数えてみれば、どうみても47行13列には見えない。見えるのは10行12列のみである。ちなみに、自分が使用するPCのモニターが大きいか、文字の大きさが小さい場合は最初から16列が表示される場合もあり、12列より少なく表示される場合もある。表示しきれなかったものについては一番下の行を参照すれば良い。

```
# … with 37 more rows, and 4 more variables: Reiwa <dbl>, NHK <dbl>,
#   Region2 <dbl>, Region6 <dbl>
```

　これは出力された内容以外にも36行が更にあり（つまり、36行は省略されているだけである）、`Reiwa`、`NHK`、`Region2`と`Region6`という名の列も更にあることを意味する。データは問題なく47行13列であることが分かる。

　もし、20行を出力したい場合は`print(オブジェクト名, n = 20)`と入力する。

```{r}
#| filename: "Code 46"
print(my_data, n = 20)
```

　最初の6行のみを出力する場合は`head()`、最後の6行を出力する場合は`tail()`を使う。

```{r}
#| filename: "Code 47"
# my_dataの最初の6行を出力
head(my_data) # print(my_data, n = 6) と同じ 
```

```{r}
#| filename: "Code 48"
tail(my_data) # my_dataの最後の6行を出力
```

　6行でなく、任意の行数を指定したい場合は`head()`、または`tail()`内に`n = ...`を追加する。このような表形式のデータをRでは**データフレーム**（data.frame）と呼び、ベクトル、リストと共に最も頻繁に使うデータ構造である。これらについては[第8回「データ構造」](datastructure.qmd)で解説する。

### 文字化けが生じる場合

　本講義ではJDCat分析ツールを利用する場合、宋が提供した資料と同じ結果が得られることが保証されている。しかし、自分のPCにRをインストールして使用する場合、文字化けが生じる可能性がある。これは文字のロケール（locale）が原因である（具体的には世界標準のUTF-8を使用するmacOS/Linuxと、日本語表示に独自仕様を使用するWindowsの違い）。この場合、自分のPCのOSによって対処方法が異なる。ここでは`read_csv()`で表形式データを読み込む際、文字化けに対処する方法を紹介する[^shift-jis]。

[^shift-jis]: しかし、最新のRはWindows版でもUTF-8がデフォルトとなっているため、問題が生じない可能性は低い。また、自分のPCがUTF-8であっても、手元のデータがUTF-8でないと文字化けが生じうる（主に日本政府が提供するデータはUTF-8でないケースが多い）。

**ケース1:** 自分のPCがWindowsの場合

　自分のPCが日本語Windowsの場合、世界標準ロケールであるUTF-8を正しく認識できない可能性がある。この場合、`read_csv()`内に`locale = locale(encoding = "UTF-8")`を追加する。

```{r}
#| filename: "Code 49"
#| eval: false
read_csv("パスを含むファイル名", locale = locale(encoding = "UTF-8"))
```

　ただし、これでも文字化けが生じるのであれば、自分のRが最新バージョン（UTF-8がベース）であり、手元のデータがShift-JISである可能性が高い。この場合は、macOS/Linuxと同じ方法で対処する（以下参照）。

**ケース2:** 自分のPCがmacOS/Linuxの場合（JDCat分析ツールもこれに該当）

　これは主にWindowsで作成されたデータを読み込む際に生じる。日本語Windowsで作成されたデータの場合、ロケールがShift-JISである可能性が高い。とりわけ日本政府/自治体が作成・公開するデータの多くが未だShift-JISである。この場合、`read_csv()`内に`locale = locale(encoding = "Shift_JIS")`を追加する。

```{r}
#| filename: "Code 50"
#| eval: false
read_csv("パスを含むファイル名", locale = locale(encoding = "Shift_JIS"))
```

### Excel形式ファイルの読み込み

　本講義ではExcelで作成されたデータ（`.xlsx`、または`.xls`形式ファイル）を使わないが、`.xlsx`、または`.xls`ファイルを読み込む場合は{readxl}パッケージの`read_excel()`関数を使用すれば良い。ここではコードの例のみ掲載する。

```{r}
#| filename: "Code 51"
#| eval: false
# {readxl}パッケージがない場合、install.packages("readxl")でインストールしておく。
library(readxl)

# sheet引数は省略可能。省略した場合1番目のシートが読み込まれる。
my_data <- read_excel("パスを含むファイル名", sheet = シートの番号)
```

## 教科書

* 『私たちのR』
   * 「[ファイルシステム](https://www.jaysong.net/RBook/filesystem.html)」
   * 「[基本的な操作](https://www.jaysong.net/RBook/rbasic.html)」
   * 「[データ構造](https://www.jaysong.net/RBook/datastructure.html#structure-vector)」
   * 「[データの入出力](https://www.jaysong.net/RBook/io.html)」
   * 「[データ型](https://www.jaysong.net/RBook/datatype.html#type-numeric)」