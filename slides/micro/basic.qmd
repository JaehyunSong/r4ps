---
subtitle: "第3回 Rの基本的な操作とベクトル操作"
date: "2024/4/25"
format: revealjs
metadata-files: 
  - _slide.yml
---

## プロジェクト機能のすゝめ

* ファイルの読み込み/書き出しの際にパス問題が生じる場合が多い。
* 毎回の実習、課題用にプロジェクトを作成することを強く推奨する。
   * プロジェクトを使わない場合、本スライド/資料上のコードの再現性は保証しない。
* プロジェクトの作成方法はサポートページの「[Rの使い方 > プロジェクト管理](https://www.jaysong.net/micro-book/intro/project.html)」を参照

# 様々な演算子

## 電卓としてのRと算術演算子

* **Step 1**: File > New File > R Script
* **Step 2**: Sourceペインの大きさを最大化する。
* **Step 3**: Sourceペインに以下のように入力する

```{r}
#| eval: false
1 + 2 + 3
```

* **Step 4**: Step 3で入力した行に移動し、「Cmd（⌘） + Return（macOS）」または「Ctrl + Enter（Linux/Windows）」
  * Consoleペインに以下のように出力されればOK

```{r}
#| echo: false
1 + 2 + 3
```

## Rの算術演算子

* 結果として何らかの**数字**が返される
* 累乗（`^`）を除き、**演算子の前後にはスペースを入れる**のがRの流儀
  * 必須ではないが、コードが読みやすくなる

|演算子|意味|例|結果|
|:---:|---|---|---:|
|`+`|和|`2 + 5`|7|
|`-`|差|`2 - 8`|-6|
|`*`|積|`7 * 3`|21|
|`/`|商|`16 / 5`|3.2|
|`^`、`**`|累乗（べき乗）|`2^3`または`2 ** 3`|8|
|`%%`|剰余 (モジュロ)|`18 %% 7`|4|
|`%/%`|整数商|`18 %/% 7`|2|

## Rの論理演算子

* 真（`TRUE`）か偽（`FALSE`）の値を返す演算子

```{r}
3 > 2 # 3は2より大きいか
5 <= 10 # 5は10以下か
2 + 3 == 1 # 2 + 3は1に等しいか
2 + 2 != 2 * 2 # 2 + 3は2 * 2と等しくないか
(2 + 2) != (2 * 2) # こっちの方がもう少し読みやすい
```

## Rの論理演算子（まとめ）

* 「等しい」は`=`でなく、`==`であることに注意すること
   * `=`は代入演算子として機能する（他の言語と同じ）。

|演算子|意味|例|結果|
|---|---|---|---|
|`x < y`|`x`は`y`より小さい|`3 < 1`|`FALSE`|
|`x <= y`|`x`は`y`と等しいか、小さい|`2 <= 2`|`TRUE`|
|`x > y`|`x`は`y`より大きい|`6 > 5`|`TRUE`|
|`x >= y`|`x`は`y`と等しいか、大きい|`4 >= 5`|`FALSE`|
|`x == y`|`x`と`y`は等しい|`(2 + 3) == (4 + 1)`|`TRUE`|
|`x != y`|`x`と`y`は等しくない|`((2 * 3) + 1) != (2 * (3 + 1))`|`TRUE`|

## 論理演算子: ANDとOR

#### AND演算子: `&`

* `&`を挟む左右の**両側**が`TRUE`の場合のみ`TRUE`を返す

```{r}
(2 + 3 == 5) & (1 * 2 == 3) # TRUE and FALSEだから
(2 + 2 == 4) & (2 * 2 == 4) # TRUE and TRUEだから
```

<br/>

#### OR演算子: `|`

* `|`を挟む左右の**片側、あるいは両側**が`TRUE`の場合のみ`TRUE`を返す

```{r}
(2 + 3 == 5) | (1 * 2 == 3) # TRUE or FALSEだから
(2 + 2 != 4) | (2 * 2 != 4) # FALSE or FALSEだから
```

## 練習問題

1. $\frac{1234 \times 4321}{3}$
2. $\frac{1234 \times 4321}{3}$の余りは？
   * $(1234 \times 4321) \text{ mod } 3$とも表記する
3. $2 \times 3$ と $2 + 3$ は等しいか
4. $1009 \text{ mod } 3$ は0か
5. $5^5$ は100**以上**、かつ1000**未満**であるか

## 練習問題（答え）

```{r}
(1234 * 4321) / 3
(1234 * 4321) %% 3
2 * 3 == 2 + 3
1009 %% 3 == 0
(5^5 >= 100) & (5^5 < 1000)
```

# ベクトル

## 200行のコードを書いてみよう

:::: {.columns}

::: {.column width="40%"}
* 123454321 $\times$ 2を計算してみよう
* 123454321 $\times$ 3を計算してみよう
* 123454321 $\times$ 4を計算してみよう
* ...
* 123454321 $\times$ 199を計算してみよう
* 123454321 $\times$ 200を計算してみよう
:::

::: {.column width="60%"}
```{r}
#| eval: false
123454321 * 2
123454321 * 3
123454321 * 4

...

123454321 * 199
123454321 * 200
```
:::

::::

<br/>

#### 効率的な方法は?

* `123454321`をコピーし貼り付けながら計算を繰り返す
* `123454321`に`x`という名前を付けて、`x * 1`のように表記する

## Rにおけるベクトル

ベクトル（vector）: Rにおけるデータの最小単位

* ベクトル内の全ての要素（element）は同じデータ型（数値型、文字型など）
  * 数値と文字列が混在するベクトルは作成不可
* `c()`関数で作成
  * `()`の中にベクトルの要素を入力
  * ベクトルの長さが2以上の場合、各要素を`,`（半角コンマ）で区切る。
     * 必須ではないが、`,`の後ろには半角スペースを入れるとコードが読みやすくなる（前は不要）。
  * 長さ1のベクトルの場合、`c()`は省略可能
     * `x <- cat("cat")`でも、`x <- "cat"`でも良い

## ベクトルの作成

* `<-`演算子で格納
  * `ベクトル名`という名前の**オブジェクト（object）**が生成され、作業環境内に保存される。
  * 「作業環境」や「オブジェクト」の概念は次回解説
* 格納しない場合、作業環境に保存されず、出力のみ

```r
ベクトル名 <- c(要素1, 要素2, ...)
```

<br/>

**例1:** 要素が1, 2, 3, 4, 5の長さ5の数値型ベクトル

* ベクトルを`my_vector1`という名前で作業環境に格納

```{r}
my_vector1 <- c(1, 2, 3, 4, 5)
```

<br/>

**例2:** 要素が"Cat", "Lion", "Tiger"の長さ3の文字型ベクトルを`my_vector2`という名で格納

* 文字は必ず`"`か`'`で囲む

```{r}
my_vector2 <- c("Cat", "Lion", "Tiger")
```

## オブジェクトの名前

基本的にオブジェクト名は何でも良いが、いくつかの禁則事項がある

* 特殊記号、スペース禁止（例外：`_`と`.`）
   * スペースの代わりに`_`か`.`が使われるが、`_`を推奨
* 数字、または`_`、`.`で始まるオブジェクト名は使えない
* 予約語は使えない（`for`や`if`など）
   * 使える予約語もあるが、非推奨
* 日本語、ハングル、簡体字、アラビア文字も可能であるが、非推奨

<br/>

#### 良いオブジェクト名は

* オブジェクト名を見るだけで、中身の内容が想像できる
* 短いオブジェクト名
* 結論：短い、かつ具体的な名前が望ましい
   * $\Rightarrow$ どうすりゃいいんだ...

## オブジェクトの表示

#### 現在の作業環境におけるオブジェクトリスト

* **方法1：**RStudioのEnvironmentペインで確認
* **方法2：**Consoleペインで`ls()`を入力

```{r}
ls()
```

<br/>

#### オブジェクトの出力

オブジェクト名のみ入力（`print(オブジェクト名)`もOK）

```{r}
my_vector1 # print(my_vector1) でもOK
my_vector2 # print(my_vector2) でもOK
```

* **Rを再起動すると作業環境が初期化される**ため、もう一回作成する必要がある。
  * コードを記録し、残すことが重要

## 比較

コードは一行増えたものの、全体的にはコードの量が著しく減る。

* ただし、200行書かないといけない点は変わらない。
   * より効率的な方法は?
   * $\rightarrow$ ベクトル・リサイクル（vector recycle）

:::: {.columns}

::: {.column width="49%"}
```{r}
#| collapse: true
123454321 * 2
123454321 * 3
123454321 * 4
123454321 * 5
```
:::

::: {.column width="2%"}
:::

::: {.column width="49%"}
```{r}
#| collapse: true
x <- 123454321
x * 2
x * 3
x * 4
x * 5
```
:::

::::

## 等差数列ベクトルの作り方

:::: {.columns}

::: {.column width="40%"}
公差 = 1の等差数列

* `:`演算子を利用

```{r}
c(1, 2, 3, 4, 5, 6, 7)
1:7
8:3
```
:::

::: {.column width="2%"}
:::

::: {.column width="58%"}
公差 $\neq$ 1の等差数列

* `seq()`関数の使用 (`by`で公差を指定)

```{r}
c(1, 3, 5, 7, 9)
seq(1, 9, by = 2)   # 1から9までの公差2の等差数列
seq(1, 5, by = 0.5) # 1から5までの公差0.5の等差数列
seq(8, 3, by = -1)  # 8から3までの公差-1の等差数列
```
:::

::::

## ベクトル同士の演算

**例)** ベクトル`X`とベクトル`Y`同士の演算

* **ケース1：** `X`の長さ = `Y`の長さ
* **ケース2：** `X`の長さ $\neq$ `Y`の長さ

<br/>

**参考)** ベクトルの長さの求め方

* `length()`関数を使用

```{r}
length(my_vector1) # c(1, 2, 3, 4, 5)
length(my_vector2) # c("Cat", "Lion", "Tiger")
```

## ケース1: ベクトルの長さが同じ場合

* 同じ位置の要素同士の演算

|ベクトル/位置|1番目|2番目|3番目|4番目|5番目|6番目|
|---|:---:|:---:|:---:|:---:|:---:|:---:|
|`my_vec1`|1|2|3|4|5|6|
||$\times$|$\times$|$\times$|$\times$|$\times$|$\times$|
|`my_vec2`|0|1|2|0|1|2|
|結果|0|2|6|0|5|12|

<br/>

```{r}
# my_vec1とmy_vec2は同じ長さ
my_vec1 <- c(1, 2, 3, 4, 5, 6) # 長さ6のベクトル
my_vec2 <- c(0, 1, 2, 0, 1, 2) # 長さ6のベクトル
my_vec1 * my_vec2
```

## ケース2: ベクトルの長さが異なる場合

* 短い方のベクトルがリサイクルされる（**ベクトル・リサイクル**）。
  * `my_vec4`の方が短いため、足りない分（太字の部分）はリサイクルされる。

|ベクトル/位置|1番目|2番目|3番目|4番目|5番目|6番目|
|---|:---:|:---:|:---:|:---:|:---:|:---:|
|`my_vec3`|1|2|3|4|5|6|
||$\times$|$\times$|$\times$|$\times$|$\times$|$\times$|
|`my_vec4`|0|1|**0**|**1**|**0**|**1**|
|結果|0|2|0|4|0|6|

<br/>

```{r}
# my_vec3とmy_vec4の長さは異なる
my_vec3 <- c(1, 2, 3, 4, 5, 6) # 長さ6のベクトル
my_vec4 <- c(0, 1)             # 長さ2のベクトル
my_vec3 * my_vec4
```

## 最初の問題

結果はどのコードでも同じ

::: {.panel-tabset}

### コード

:::: {.columns}

::: {.column width="30%"}

答え（3行 ver.）

```{r}
#| eval: false
x <- 123454321
y <- 2:200
x * y
```
:::

::: {.column width="5%"}
:::

::: {.column width="30%"}

答え（2行 ver.）

```{r}
#| eval: false
x <- 123454321
x * 2:200
```

または、

```{r}
#| eval: false
x <- 2:200
123454321 * x
```
:::

::: {.column width="5%"}
:::

::: {.column width="30%"}

答え（1行 ver.）

```{r}
#| eval: false
123454321 * 2:200
```
:::

::::

### 結果

```{r}
123454321 * 2:200
```

:::

## ベクトル要素の抽出

ベクトルから任意の要素を抽出する2つの方法

* **方法1**: 抽出する要素の位置を指定する。
* **方法2**: 論理演算子を利用する。

<br/>

**例)** 11, 12, 13, ..., 19, 20が格納された`my_vec5`

```{r}
my_vec5 <- 11:20 # my_vec <- seq(11, 20, by = 1) と同じ
my_vec5
```

<br/>

|位置|1|2|3|4|5|6|7|8|9|10|
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|`my_vec5`|11|12|13|14|15|16|17|18|19|20|

* 他の言語と違い、位置の番号は0からでなく、**1からスタート**することに注意

## 要素の抽出: 位置指定

* `ベクトル名[抽出する要素の位置]`

**例1)** `my_vec5`の3番目の要素

```{r}
my_vec5[3]
```

**例2)** `my_vec5`の2, 3, 4, 5番目の要素

* `[]`内に抽出する要素の位置を表すベクトルを指定
* `pos_vec`、`c(2, 3, 4, 5)`、`seq(2, 5, by = 1)`、`2:5`はすべて同じ意味

```{r}
pos_vec <- c(2, 3, 4, 5)
my_vec5[pos_vec]
my_vec5[c(2, 3, 4, 5)]
my_vec5[seq(2, 5, by = 1)]
my_vec5[2:5]
```

## 要素の抽出: 論理演算子の利用

* それぞれの要素に対し、抽出するか（`TRUE`）しないか（`FALSE`）を指定
* 表形式データにおける行の抽出を自由自在に操るためには必須知識（第9回）

**例1)** `my_vec5`から1, 4, 7, 9, 10番目の要素を抽出

* `[]`内にベクトルの長さ分のベクトルを更に入力する必要があるため、あまり使わない方法

```{r}
# my_vec5[c(1, 4, 7, 9, 10)] と同じ結果
my_vec5[c(TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, TRUE)]
```

**例2)** `my_vec5`から奇数のみ抽出（論理演算子の利用）

```{r}
# my_vec5を2で割った場合、余りが1ならTRUE、その他はFALSE
my_vec5 %% 2 == 1
my_vec5[my_vec5 %% 2 == 1]
```

# データの入出力

## 表形式データの読み込み

{tidyverse}パッケージが提供する`read_csv()`関数を利用

* `オブジェクト名 <- read_csv("パスを含むファイル名")`
* 以下の例はプロジェクト・フォルダー内に`Data`という名の下位フォルダーがあり、その中に`Pref_Vote.csv`が保存されている場合。
   * パスは`"Data/Pref_Vote.csv"`
   * JDCat分析ツールを使用する場合、予めデータをアップロードしておくこと。
      * ファイルアップロードの方法はサポートページの「Rの使い方 > [ファイル管理](https://www.jaysong.net/r4ps/intro/file.html){target="_blank"}」を参照
      * データ（`Pref_Vote.csv`）はLMSから入手

```{r}
#| message: false
library(tidyverse)
my_data <- read_csv("Data/Pref_Vote.csv")
```

:::{.callout-note icon=false}
## 注意：`read_csv()`と`read.csv()`は区別しよう。

　両方`.csv`形式データを読み込む関数であるが、`read.csv()`はR内蔵関数、`read_csv()`は{tidyverse}を読み込まないと使用できない関数である。後者の方が見やすいメリットがある。本講義では`read_csv()`のみを使用する。課題の際、`read.csv()`関数を使うと**減点**とする。
:::

## データの出力

* `オブジェクト名`、または`print(オブジェクト名)`

```{r}
# my_dataの中身の出力するコード
# print(my_data) でもOK
my_data
```

## データが全部見えない?

**1行目**

* 意味: 47行13列の表形式データ

```
# A tibble: 47 × 13
```

<br/>

**最終行**

* 意味: 表示された行以外にも更に37行があり、`Region2`と`Region6`は画面では省略されている。
   * 文字サイズが小さい or 画面が大きい場合は省略されず、13列がすべて出力される場合もある。

```
# … with 37 more rows, and 2 more variables: Region2 <dbl>, Region6 <dbl>
```

## 読み込んだデータの出力


::: {.panel-tabset}

### デフォルト

* `オブジェクト名`、または`print(オブジェクト名)`

```{r}
my_data
```

### 出力行数の指定

* `print(オブジェクト名, n = 行数)`

```{r}
print(my_data, n = 15)
```

### 最後の6行

* `tail(オブジェクト名)`

```{r}
tail(my_data)
```

### 最後のn行

* `tail(オブジェクト名, n = 行数)`
   * `head()`で使うと**最初**の`n`行の出力も可能

```{r}
tail(my_data, n = 10)
```

:::

## `.csv`以外の表形式データ

`.csv`形式ファイルは表形式データの定番であり、標準

* 他にも様々な形式のデータがあり、Rで読み込み可能（以下は一部の例）

|ソフトウェア名|拡張子|使用パッケージ|関数|
|:---|:---|:---|:---|
|Microsoft Excel|`.xls`、`.xlsx`|{readxl}|`read_excle()`|
|LibreOffice / OpenOffice|`.ods`|{readODS}|`read_ods()`|
|SPSS|`.sav`|{haven}|`read_stata()`|
|Stata|`.dta`|{haven}|`read_spss()`|
|SAS|`.sas7bdat`|{haven}|`read_sas()`|

